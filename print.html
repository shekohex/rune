<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rune Programming Language</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="2_introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="3_getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="4_concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4_1_variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="4_2_control_flow.html"><strong aria-hidden="true">4.2.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="4_3_loops.html"><strong aria-hidden="true">4.3.</strong> Loops</a></li><li class="chapter-item expanded "><a href="4_4_pattern_matching.html"><strong aria-hidden="true">4.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="4_5_template_strings.html"><strong aria-hidden="true">4.5.</strong> Template strings</a></li></ol></li><li class="chapter-item expanded "><a href="5_types.html"><strong aria-hidden="true">5.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_1_primitives.html"><strong aria-hidden="true">5.1.</strong> Primitives and references</a></li><li class="chapter-item expanded "><a href="5_2_vectors.html"><strong aria-hidden="true">5.2.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="5_3_objects.html"><strong aria-hidden="true">5.3.</strong> Objects</a></li><li class="chapter-item expanded "><a href="5_4_tuples.html"><strong aria-hidden="true">5.4.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="5_5_functions.html"><strong aria-hidden="true">5.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="5_6_structs.html"><strong aria-hidden="true">5.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="5_7_enums.html"><strong aria-hidden="true">5.7.</strong> Enums</a></li></ol></li><li class="chapter-item expanded "><a href="6_try_operator.html"><strong aria-hidden="true">6.</strong> Try operator</a></li><li class="chapter-item expanded "><a href="7_generators.html"><strong aria-hidden="true">7.</strong> Generators</a></li><li class="chapter-item expanded "><a href="8_async.html"><strong aria-hidden="true">8.</strong> Asynchronous programming</a></li><li class="chapter-item expanded "><a href="9_functions_closures.html"><strong aria-hidden="true">9.</strong> Functions and closures</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rune Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<blockquote>
<p>&quot;Why am I building a programming language? Is it even possible?&quot;</p>
</blockquote>
<p>This question keeps rolling around in my head as I'm typing out the code that is
slowly becoming a new <em>thing</em>.
Programming itself is like magic, you imagine it in your mind, write it out, and
there it is.
Doing <em>stuff</em> which wasn't being done before.</p>
<p>Truth be told, I'm scared that people will tell me that I'm wasting my time.
This has already been done, or &quot;Why not just use X?&quot;.
Something so glaringly obvious that all of my efforts are in vain.</p>
<p>You actually don't need a reason.
It can simply be for The Joy of Creating Something, and then it's just you
spending your own time as a hobby.
No harm done.</p>
<p>Anyway, here's why im making Rune.</p>
<h2><a class="header" href="#the-other-project" id="the-other-project">The other project</a></h2>
<p>Another project I've spent a lot of effort working on is <a href="https://github.com/udoprog/OxidizeBot">OxidizeBot</a>, a Twitch
bot that a streamer can use to add commands and other interactive things in
their chat.
Originally I just built it for myself, while streaming, but I'm also an
aggressive generaliser.
When I add features I always think about how it can be as generic as possible to
suit potentially many needs.</p>
<p>And when it's a personal project, the propensity in me is to the detriment of
keeping it simple.</p>
<p>...</p>
<p>Ok, confession. I <em>sometimes</em> do that professionally as well.
But I'm much less critical when doing personal projects.</p>
<p>Anyway, that meant the bot could actually be used by others.
It's starting to see a little bit of use now.
Which is actually <em>a lot</em> of fun.</p>
<p>So all the commands in the bot are written in <a href="https://rust-lang.org">Rust</a>, and compiled straight into
the bot.
This is nice, because Rust is an incredible language.
But Rust is also complex.
Not nedlessly, it's complex because it decided to tackle <em>really hard problems</em>.
To my best understanding, it's about as complex as it has to be.
<em>Most of the time</em>.</p>
<p>But it's complex enough that streamers who have very little programming
experience struggle getting up and running*.
Because of this I wanted to provide a way for them to write their own dynamic
command handlers.
Once they could just drop into a folder and <em>presto</em> - you're up and running.</p>
<blockquote>
<p>I've actually personally tutored at least two of these streamers who were
interested in learning Rust, but then you're getting further away from writing
chat commands.</p>
</blockquote>
<p>For this reason I started looking into dynamic programming languages.
Once that could be embedded into an existing Rust application with little to no
effort.</p>
<p>If you're one of those thinking that type systems are the best thing since
sliced bread. Then I'm just gonna say <strong>yes</strong>, you are right.
But type systems are also one of these complexities which can get in the way of
being productive.
And not everyone wants to learn how to climb before they can walk.</p>
<p>A number of candidates came up, but this isn't a review, so I'm just gonna jump
to the one I chose and not dwell too much on the reasons: <a href="https://github.com/jonathandturner/rhai">Rhai</a>.</p>
<p>So why is Rhai awesome:</p>
<ul>
<li>It has Rust-like syntax.</li>
<li>The runtime is fully written in mostly safe Rust, and can be embedded.</li>
</ul>
<p>Initially I wasn't going to write my own programming language.
I added support for rhai, and things worked really well.</p>
<p>But there were a few things that I wanted out of Rhai, and I was gearing up to
<a href="https://github.com/jonathandturner/rhai/commits?author=udoprog">contribute those to the project</a>.</p>
<p>So the things I wanted, beyond what was already provided by Rhai was:</p>
<ul>
<li>A stack-based virtual machine that you could write low-complexity C-ffi
bindings for, <a href="https://www.lua.org/pil/26.1.html">like Lua</a>.</li>
<li>Opinionated support for asynchronous programming.</li>
<li>A future cranelift backend.</li>
</ul>
<p>And while I believe that these are feasible in Rhai, I also think the project
would emerge as a different one on the other side.
And I wanted a fresh slate of design constraints to find my own compromises.
To discover freely what works and doesn't work well.</p>
<p>That being said, Rhai has been a huge inspiration for Rune.
If you need an embedded scripting engine that is more mature right now than
Rune, please go check it out!</p>
<p>‚Äî John-John Tedro</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome the <em>The Rune Programming Language</em>, a reference guide about Rune.</p>
<p>Rune is an embeddable dynamic programming language that runs on a stack machine.</p>
<p>The goal of Rune is to reimagine Rust as a dynamic programming language.
Trying to copy as many concepts as possible, and remixing ones which do not
translate into something which feels familiar.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>The first thing you need to learn about in Rune is the <code>dbg</code> function.
This is used to &quot;debug&quot; whatever values are provided to it, and can be used
by programmers in any environment to look at values in their program.</p>
<p>The <code>dbg</code> function output information on its arguments to stdout, but its exact
behavior is specific to the environment in which Rune is used.</p>
<p>When embedded into a larger application it might not be suitable to output to
stdout, so it might for example have been configured to write to a log file
instead.</p>
<p>Rune does also provide a <code>print</code> and <code>println</code> functions which can be used to
write directly to stdout, but these might be disabled if they're not suitable
for the environment used.</p>
<p>For now, lets use <code>println</code> when printing to stdout.</p>
<pre><code class="language-rust noplaypen">fn main() {
    println(&quot;Hello World&quot;);
}
</code></pre>
<p>You can execute this with the <code>rune-cli</code>, a commandline interface to the rune
language that comes with this project.</p>
<p>After each code snipped there will be a terminal showing the command used, and
its output.
Like this:</p>
<pre><code class="language-text">$&gt; cargo run -- scripts/hello_world.rn
Hello World
== () (412.2¬µs)
</code></pre>
<p>At the end of the script you see this rather odd looking line:</p>
<pre><code class="language-text">== () (412.2¬µs)
</code></pre>
<p>This simply means that the script evaluated to a unit, or a <code>()</code>.
And that the execution took <code>412</code> microseconds.</p>
<blockquote>
<p>Cool Hint:
Any function that doesn't have a return value returns a unit.</p>
</blockquote>
<p>So now you know how to run Rune scripts. Well done!</p>
<p>Let's move on with the rest of the book.</p>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<p>This chapter covers common concepts that appear in almost all programming
languages, and how they work in Rune.</p>
<p>These should be familiar to anyone who's used an imperative programming
languages before.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<p>Variables in Rune are defined using the <code>let</code> keyword.
In contrast to Rust, all variables in Rune are mutable and do not require a
<code>mut</code> keyword to change.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let x = 5;
    println(`The value of x is: {x}`);
    x = 6;
    println(`The value of x is: {x}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/variables.rn
The value of x is: 5
The value of x is: 6
</code></pre>
<h2><a class="header" href="#reference-counting-and-ownership" id="reference-counting-and-ownership">Reference Counting and Ownership</a></h2>
<p>In rune, all variables are reference counted and can be shared across multiple
variables.</p>
<p>This means that all variables in rune have <em>shared ownership</em>.
This means that every variable that points to an object on the stack, points to
<em>the same instance</em> of that object.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`{object.field}`);
    object2.field = 2;
    println(`{object2.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/shared_ownership.rn
1
2
== () (913.4¬µs)
</code></pre>
<p>This can potentially cause issues if we call an external function that expects
to take ownership of its arguments.</p>
<p>We say that functions like these <em>move</em> their argument, and if we try to use a
variable which has been moved the virtual machine will error.</p>
<blockquote>
<p>Note: Below we use the <code>drop</code> function, which is a built-in function that will
take its argument and free it.</p>
</blockquote>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);
    println(`field: {object.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/take_argument.rn
field: 1
error: virtual machine error
  ‚îå‚îÄ scripts/book/4_1/take_argument.rn:6:22
  ‚îÇ
6 ‚îÇ     println(`field: {object.field}`);
  ‚îÇ                      ^^^^^^^^^^^^ failed to access value: not accessible for shared access

</code></pre>
<p>If you need to, you can test if a variable is still accessible with
<code>is_readable</code> and <code>is_writable</code>.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);

    if is_readable(object) {
        println(`field: {object.field}`);
    } else {
        println(&quot;object is no longer readable üò¢&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/is_readable.rn
field: 1
object is no longer readable üò¢
</code></pre>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<p>Rune supports your typical forms of control flow.</p>
<h2><a class="header" href="#return-keyword" id="return-keyword"><code>return</code> Keyword</a></h2>
<p>The <code>return</code> keyword allows for returning from the current function.
If specified without an argument, the function will return a unit <code>()</code>.</p>
<p>The last statement in a function is known as an <em>implicit return</em>, and will be
what the function returns by default unless a <code>return</code> is specified.</p>
<pre><code class="language-rust noplaypen">fn foo(n) {
    if n &lt; 1 {
        return &quot;less than one&quot;;
    }

    &quot;something else&quot;
}

fn main() {
    println(foo(0)) // =&gt; outputs: &quot;less than one&quot;
    println(foo(10)); // =&gt; outputs: &quot;something else&quot;
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/numbers_game.rn
less than one
something else
== () (3.8608ms)
</code></pre>
<h2><a class="header" href="#if-expressions" id="if-expressions"><code>if</code> Expressions</a></h2>
<p>If expressions allow you to provide a condition with one or more code branches.
If the condition is <code>true</code>, the provided block of code will run.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;The number *is* smaller than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/conditional.rn
The number *is* smaller than 5
== () (5.108ms)
</code></pre>
<p>Optionally, we can add another branch under <code>else</code>, which will execute in case
the condition is false.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else {
        println(&quot;the number is 5 or bigger&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/conditional_else.rn
the number is smaller than 5
== () (196.1¬µs)
</code></pre>
<p>We can also add an arbitrary number of <code>else if</code> branches, which allow us to
specify many different conditions.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else if number == 5 {
        println(&quot;the number is exactly 5&quot;);
    } else {
        println(&quot;the number is bigger than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/conditional_else_ifs.rn
the number is smaller than 5
== () (227.9¬µs)
</code></pre>
<p>Do note however that if you have <em>many</em> conditions, it might be cleaner to use
a <code>match</code>.</p>
<p>This will be covered in a later section, but here is a sneak peek:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    match number {
        n if n &lt; 5 =&gt; {
            println(&quot;the number is smaller than 5&quot;);
        }
        5 =&gt; {
            println(&quot;the number is exactly 5&quot;);
        }
        n =&gt; {
            println(&quot;the number is bigger than 5&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/first_match.rn
the number is smaller than 5
== () (124.2¬µs)
</code></pre>
<h1><a class="header" href="#loops" id="loops">Loops</a></h1>
<p>Loops are a fundamental building block common to many programming languages.
This is no exception in Rune.
Loops allow you to execute a block of code until a specific condition is
reached, which can be a powerful tool for accomplishing programming tasks.</p>
<h2><a class="header" href="#break-keyword" id="break-keyword"><code>break</code> Keyword</a></h2>
<p>Every loop documented in this section can be <em>terminated early</em> using the
<code>break</code> keyword.</p>
<p>When Rune encounters a break, it will immediately jump out of the loop it is
currently in and continue running right after it.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let value = 0;

    while value &lt; 100 {
        if value &gt;= 50 {
            break;
        }

        value = value + 1;
    }

    println(`The value is {value}`); // =&gt; The value is 50
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/while_loop.rn
The value is 50
== () (501.1¬µs)
</code></pre>
<h2><a class="header" href="#loop-expressions" id="loop-expressions"><code>loop</code> Expressions</a></h2>
<p>The <code>loop</code> keywords builds the most fundamental form of loop in Rune.
One that repeats unconditionally forever, until it is exited using another
control flow operator like a <code>break</code> or a <code>return</code>.</p>
<pre><code class="language-rust noplaypen">use time::Duration;

fn main() {
    loop {
        println(&quot;loop forever&quot;);
        time::delay_for(Duration::from_secs(1)).await;
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/loop_forever.rn
Hello forever!
Hello forever!
Hello forever!
...
</code></pre>
<blockquote>
<p>Hint: If you want this one to end, you're gonna have to kill it with <code>CTRL+C</code>.</p>
</blockquote>
<p>We're also using an asynchronous function called <code>delay_for</code> above to avoid
spamming our terminals too much.
Well talk more about these in a later section.</p>
<p>When broken out of, loops produce the value provided as an argument to the
<code>break</code> keyword.
By default, this is simply a unit <code>()</code>.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let counter = 0;

    let total = loop {
        counter = counter + 1;

        if counter &gt; 10 {
            break counter;
        }
    };

    println(`The final count is: {total}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/loop_break.rn
The final count is: 11
== () (281.5¬µs)
</code></pre>
<h1><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h1>
<p>In this section we will be discussing <em>Pattern Matching</em>.</p>
<p>Pattern matching is a flexible mechanism that allows for validating the
structure and type of the argument, while also destructing it to give easy
access to what you need.</p>
<p>Below are some examples of its common uses to match on branch conditions:</p>
<pre><code class="language-rust noplaypen">fn match_input(n) {
    match n {
        1 =&gt; println(&quot;The number one.&quot;),
        n if n is int =&gt; println(`Another number: {n}.`),
        [1, 2, n, ..] =&gt; println(`A vector starting with one and two, followed by {n}.`),
        &quot;one&quot; =&gt; println(&quot;One, but this time as a string.&quot;),
        _ =&gt; println(&quot;Something else. Can I go eat now?&quot;),
    }
}

fn main() {
    match_input(1);
    match_input(2);
    match_input([1, 2, 42, 84]);
    match_input(&quot;one&quot;);
    match_input(#{field: 42});
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/big_match.rn
The number one.
Another number: 2.
A vector starting with one and two, followed by 42.
One, but this time as a string.
Something else. Can I go eat now?
== () (5.691ms)
</code></pre>
<p>We will be covering each of these variants in detail in the coming sections.</p>
<h2><a class="header" href="#matching-literals" id="matching-literals">Matching Literals</a></h2>
<p>Literals are the simplest form of matching. Where we test if the branch is
exactly equal to a literal.</p>
<p>Literals take a number of form:</p>
<ul>
<li>A literal unit, simply <code>()</code>.</li>
<li>A literal boolean, like <code>true</code> or <code>false</code>.</li>
<li>A literal character, like <code>'a'</code> or <code>'„ÅÇ'</code>.</li>
<li>A literal integer, like <code>42</code>.</li>
<li>A string, like <code>&quot;Steven Universe&quot;</code>.</li>
<li>A vector, like the numbers <code>[4, 8, 15, 16, 23, 42]</code> or the empty vector <code>[]</code>.</li>
<li>A tuple, like <code>(&quot;Steven Universe&quot;, 42)</code>.</li>
<li>An object, like the numbers <code>{&quot;name&quot;: &quot;Steven Universe&quot;}</code> or the empty <code>{}</code>.</li>
</ul>
<p>Finally, literals can be <em>any</em> combination of the above.
Even <code>{&quot;items&quot;: [&quot;Sword&quot;, &quot;Bow&quot;, &quot;Axe&quot;]}</code> is a literal that can be matched over.</p>
<h2><a class="header" href="#match-bindings" id="match-bindings">Match Bindings</a></h2>
<p>In a pattern, every literal value can also be replaced with an ignore directive
or a binding.</p>
<p>The ignore directive looks like an underscore <code>_</code>, which tells rune to <em>ignore</em>
the value, allowing it to have any value.</p>
<pre><code class="language-rust noplaypen">fn test_ignore(vector) {
    match vector {
        [_, 2] =&gt; println(&quot;Second item in vector is 2.&quot;),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/ignore.rn
Second item in vector is 2.
== () (281.3¬µs)
</code></pre>
<p>In contrast to ignoring, we cal also <em>bind</em> the value to a variable that is then
in scope of the match arm.</p>
<pre><code class="language-rust noplaypen">fn test_ignore(vector) {
    match vector {
        [_, b] =&gt; println(`Second item in vector is {b}.`),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/bind.rn
Second item in vector is 2.
== () (6.25ms)
</code></pre>
<p>Here are some more examples:</p>
<ul>
<li><code>[_, a, b]</code> which will ignore the first, but then capture the second and third
element in the vector.</li>
<li><code>{&quot;name&quot;: name}</code> will capture the <code>name</code> value out of the specified object.</li>
</ul>
<p>Finally we can also add the sequence <code>..</code> to ask Rune to <em>ignore</em> any additional
values in a collection that might be present when matching a vector or an
object.</p>
<pre><code class="language-rust noplaypen">fn describe_car(car) {
    match car {
<span class="boring">        {&quot;make&quot;: year, ..} if year &lt; 1950 =&gt; &quot;What, where did you get that?&quot;,
</span><span class="boring">        {&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: year, ..} if year &gt;= 2000 =&gt; &quot;Pretty fast!&quot;,
</span>        _ =&gt; &quot;Can't tell üòû&quot;,
    }
}

fn main() {
    println(describe_car(#{&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: 2000}));
    println(describe_car(#{&quot;model&quot;: &quot;Honda&quot;, &quot;make&quot;: 1980}));
    println(describe_car(#{&quot;model&quot;: &quot;Volvo&quot;, &quot;make&quot;: 1910}));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/fast_cars.rn
Pretty fast!
Can't tell üòû
What, where did you get that?
== () (5.3533ms)
</code></pre>
<h1><a class="header" href="#template-strings" id="template-strings">Template strings</a></h1>
<p>If you've been paying attention on previous sections you might have seen a
rather odd looking syntax like <code>`Hello {name}`</code>.</p>
<p>These are called <em>template strings</em>, and allow the programmer to conveniently
build strings using variables from the environment.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let age = 30;
    println(`I am {age} years old!`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_5/basic_template.rn
I am 30 years old!
== () (4.5678ms)
</code></pre>
<p>Template strings are accelerated by the Vm, each argument uses a <em>display
protocol</em> and it can be a very efficient to build complex strings out of it.</p>
<h2><a class="header" href="#the-display-protocol" id="the-display-protocol">The display protocol</a></h2>
<p>The display protocol is a function that can be implemented by any <em>external</em>
type which allows it to be used in a template string.</p>
<p>It expects a function with the signature <code>fn(&amp;self, buf: &amp;mut String) -&gt; fmt::Result</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Write as _;

#[derive(Debug)]
pub struct StatusCode {
    inner: u32,
}

impl StatusCode {
    fn display(&amp;self, buf: &amp;mut String) -&gt; fmt::Result {
        write!(buf, &quot;{}&quot;, self.inner)
    }
}

pub fn module() -&gt; Result&lt;runestick::Module, runestick::ContextError&gt; {
    let mut module = runestick::Module::new(&amp;[&quot;http&quot;]);
    module.inst_fn(runestick::STRING_DISPLAY, StatusCode::display)?;
    Ok(module)
}
<span class="boring">}
</span></code></pre></pre>
<p>This is what allows status codes to be formatted into template strings, any
types which do not implement this protocol will fail to run.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let vec = [1, 2, 3];
    println(`{vec}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_5/not_a_template.rn
error: virtual machine error
  ‚îå‚îÄ scripts/book/4_5/not_a_template.rn:3:13
  ‚îÇ
3 ‚îÇ     println(`{vec}`);
  ‚îÇ             ^^^^^^^ `vector` does not implement the `string_display` protocol
</code></pre>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p>Types in Rune are identified uniquely by their <em>path</em>.
A path is a scope-separated identifier, like <code>std::float</code>.</p>
<p>This identifies a type object.</p>
<p>These can be used to perform basic type checking, like this:</p>
<pre><code class="language-rust noplaypen">use std::test::assert;

fn main() {
    assert(() is unit, &quot;units should be units&quot;);
    assert(true is bool, &quot;bools should be bools&quot;);
    assert('a' is char, &quot;chars should be chars&quot;);
    assert(b'a' is byte, &quot;bytes should be bytes&quot;);
    assert(42 is int, &quot;integers should be integers&quot;);
    assert(42.1 is float, &quot;floats should be floats&quot;);
    assert(&quot;hello&quot; is String, &quot;strings should be strings&quot;);
    assert(#{&quot;hello&quot;: &quot;world&quot;} is Object, &quot;objects should be objects&quot;);
    assert([&quot;hello&quot;, &quot;world&quot;] is Vec, &quot;vectors should be vectors&quot;);
}
</code></pre>
<p>Conversely, the type check would fail if it's not valid.</p>
<pre><code class="language-rust noplaypen">use std::test::assert;

fn main() {
    assert([&quot;hello&quot;, &quot;world&quot;] is String, &quot;vectors should be strings&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/bad_type_check.rn
error: virtual machine error
  ‚îå‚îÄ scripts/book/5/bad_type_check.rn:4:5
  ‚îÇ
4 ‚îÇ     assert([&quot;hello&quot;, &quot;world&quot;] is String, &quot;vectors should be strings&quot;);
  ‚îÇ     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ panicked `assertion failed `vectors should be strings``
</code></pre>
<p>So this allows us to determine which type is which and act accordingly:</p>
<pre><code class="language-rust noplaypen">fn dynamic_type(n) {
    if n is String {
        &quot;n is a String&quot;
    } else if n is Vec {
        &quot;n is a vector&quot;
    } else {
        &quot;n is unknown&quot;
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/type_check.rn
n is a String
n is a vector
n is unknown
== () (1.0544ms)
</code></pre>
<p>A tighter way to accomplish this could be by using pattern matching:</p>
<pre><code class="language-rust noplaypen">fn dynamic_type(n) {
    if n is String {
        &quot;n is a String&quot;
    } else if n is Vec {
        &quot;n is a vector&quot;
    } else {
        &quot;n is unknown&quot;
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/type_check.rn
n is a String
n is a vector
n is unknown
== () (1.0544ms)
</code></pre>
<h1><a class="header" href="#primitives-and-references" id="primitives-and-references">Primitives and References</a></h1>
<p>Primitives are values stored immediately on the stack.
In Rust terminology, these types are <code>Copy</code>, so reassigning them to different
values will create distinct copies of the underlying value.</p>
<p>The primitives available in rune are:</p>
<ul>
<li>the unit <code>()</code>.</li>
<li>booleans, <code>true</code> and <code>false</code>.</li>
<li>bytes, like <code>b'\xff'</code>.</li>
<li>characters, like <code>'‰ªä'</code>.</li>
<li>integers, like <code>42</code>.</li>
<li>floats, like <code>3.1418</code>.</li>
</ul>
<p>You can see that these bytes are <code>Copy</code>, because assigning them to a different
variable will cause a separate copy of the variable to be used.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = 1;
    let b = a;
    a = 2;
    println(`{a}`);
    println(`{b}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_1/copy.rn
2
1
== () (691.3¬µs)
</code></pre>
<p>In contrast, other types like <em>strings</em> are stored by reference on the stack.</p>
<p>Assigning them to a different variable will only copy the reference and increase
its reference count, but they point to the same underlying data.
As shown here:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = String::from_str(&quot;Hello&quot;);
    let b = a;
    a.push_str(&quot; World&quot;);
    println(a);
    println(b);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_1/primitives.rn
Hello World
Hello World
== () (9.7406ms)
</code></pre>
<h1><a class="header" href="#vectors" id="vectors">Vectors</a></h1>
<p>A vector is a native data structure of Rune which is a dynamic list of values.
A vector isn't typed, and can store <em>any</em> rune values.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = [&quot;Hello&quot;, 42];

    dbg(values[0]);
    dbg(values.1); // items be accessed like tuples fields.

    for v in values {
        dbg(v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_2/vectors.rn
&quot;Hello&quot;
42
&quot;Hello&quot;
42
== () (5.0674ms)
</code></pre>
<p>As you can see, you can iterate over a vector because it implements the iterator
protocol.</p>
<p>It is also possible to create and use an iterator manually using <code>Vec::iter</code>,
giving you more control over it.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = [&quot;Hello&quot;, 42];

    for v in values.iter().rev() {
        dbg(v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_2/vectors_rev.rn
42
&quot;Hello&quot;
== () (2.9116ms)
</code></pre>
<h1><a class="header" href="#objects" id="objects">Objects</a></h1>
<p>Objects are anonymous hash maps, which support defining arbitrary string keys.</p>
<pre><code class="language-rust noplaypen">use std::test::assert;

fn main() {
    let values = #{};
    values[&quot;first&quot;] = &quot;bar&quot;;
    values[&quot;second&quot;] = 42;

    dbg(values[&quot;first&quot;]);
    dbg(values.second); // items be accessed like struct fields.

    if let Some(key) = values.get(&quot;not a key&quot;) {
        dbg(key);
    } else {
        println(&quot;key did not exist&quot;);
    }

    for entry in values {
        dbg(entry);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_3/objects.rn
&quot;bar&quot;
42
key did not exist
(&quot;second&quot;, 42)
(&quot;first&quot;, &quot;bar&quot;)
== () (3.3527ms)
</code></pre>
<p>These are useful because they allow their data to be specified dynamically,
which is exactly the same use case as storing unknown JSON.</p>
<p>One of the largest motivations for <em>Rune</em> to have anonymous objects is so that
we can handle JSON with an unknown structure.</p>
<pre><code class="language-rust noplaypen">fn get_commits(repo, limit) {
    let limit = limit.unwrap_or(10);

    let client = http::Client::new();
    let request = client.get(`https://api.github.com/repos/{repo}/commits`).await?;
    let response = request.header(&quot;User-Agent&quot;, &quot;Rune&quot;).send().await?;
    let text = response.text().await?;
    let json = json::from_string(text)?;

    let commits = Vec::new();
    let count = 0;

    for entry in json {
        commits.push(entry.sha);

        if count &gt;= limit {
            break;
        }

        count += 1;
    }

    commits
}

fn main() {
    for commit in get_commits(&quot;rune-rs/rune&quot;, Some(5)) {
        println(commit);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_3/json.rn
9c4bdaf194410d8b2f5d7f9f52eb3e64709d3414
06419f2580e7a18838f483321055fc06c0d75c4c
cba225dad143779a0a9543cfb05cde9710083af5
15133745237c014ff8bae53d8ff8f3c137c732c7
39ac97ab4ebe26118e807eb91c7656ab95b1fcac
3f6310eeeaca22d0373cc11d8b34d346bd12a364
== () (331.3324ms)
</code></pre>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>Tuples in Rune are a fixed-size sequences of values.
Like all other containers in Rune, tuples can contains any values.</p>
<p>In fact, they can even change the <em>type</em> of the values stored in them, if
needed.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = (&quot;Now&quot;, &quot;You&quot;, &quot;See&quot;, &quot;Me&quot;);
    dbg(values)

    values.2 = &quot;Don't&quot;;
    values.3 = &quot;!&quot;;
    dbg(values)
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_4/tuple_masquerade.rn
(&quot;Now&quot;, &quot;You&quot;, &quot;See&quot;, &quot;Me&quot;)
(&quot;Now&quot;, &quot;You&quot;, &quot;Don\'t&quot;, &quot;!&quot;)
== () (38.3136ms)
</code></pre>
<p>The following is a simple example of a function returning a tuple:</p>
<pre><code class="language-rust noplaypen">fn foo() {
    (1, &quot;test&quot;)
}

fn main() {
    dbg(foo());
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_4/basic_tuples.rn
(1, &quot;test&quot;)
== () (387.6¬µs)
</code></pre>
<p>Tuples can also be pattern matched:</p>
<pre><code class="language-rust noplaypen">fn main() {
    match (&quot;test&quot;, 1) {
        (&quot;test&quot;, n) =&gt; {
            dbg(&quot;the first part was a number:&quot;, n);
        }
        _ =&gt; {
            dbg(&quot;matched something we did not understand&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_4/tuple_patterns.rn
&quot;the first part was a number:&quot;
1
== () (7.7892ms)
</code></pre>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>Functions are truly pervasive when it comes to programming.
They encapsulate a piece of functionality and provides a contract of how they
work that can be relied on to build more complex programs.</p>
<p>In Rune, functions are declared with the <code>fn</code> keyword.
You've already seen one which is used in every example, <code>main</code>.
This is not a special function, but is simply what the Rune cli looks for when
deciding what to execute.</p>
<pre><code class="language-rust noplaypen">fn main() {
    println(&quot;Hello World&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_5/main_function.rn
Hello World
== () (277.8¬µs)
</code></pre>
<p>In Rune, you don't have to specify the return type of a function.
Given that Rune is a dynamic programming language, this allows a function to
return anything.
Every completely distinct types.</p>
<pre><code class="language-rust noplaypen">fn foo(condition) {
    if condition {
        &quot;Hello&quot;
    } else {
        1
    }
}

fn main() {
    println(`{foo(true)}`);
    println(`{foo(false)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_5/return_value.rn
Hello
1
== () (8.437ms)
</code></pre>
<p>Depending on who you talk to, this is either the best things since sliced bread
or quite scary.
It allows for a larger ability to express a program, but at the same time it can
be harder to reason on what your program will do.</p>
<h1><a class="header" href="#structs" id="structs">Structs</a></h1>
<p>Structs are like objects, except that they have a predefined structure with a
set of keys that are known at compile time and guaranteed to be defined.</p>
<p>Structs can also, like most types, have an <code>impl</code> block associated with them
which creates instance functions that you can call on an instance of that
struct.</p>
<pre><code class="language-rust noplaypen">struct User {
    username,
    active,
}

impl User {
    fn set_active(self, active) {
        self.active = active;
    }

    fn describe(self) {
        if self.active {
            println(`{self.username} is active`);
        } else {
            println(`{self.username} is inactive`);
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.set_active(true);
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_6/user_database.rn
setbac is inactive
setbac is active
== () (6.2095ms)
</code></pre>
<p>Structs can also be pattern matched, like most types.</p>
<p>But since the fields of a struct are known at compile time, the compiler can
ensure that you're only using fields which are defined.</p>
<pre><code class="language-rust noplaypen">struct User {
    username,
    active,
}

impl User {
    fn describe(self) {
        match self {
            User { username: &quot;setbac&quot;, .. } =&gt; {
                println(&quot;Yep, it's setbac.&quot;);
            }
            User { username, .. } =&gt; {
                println(`Other user: {username}.`);
            }
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.username = &quot;newt&quot;;
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_6/struct_matching.rn
Yep, it's setbac.
Other user: newt.
== () (1.0652ms)
</code></pre>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>Rune has support for <em>enumerations</em>.
These allow you to define a type with zero or more <em>variants</em>, where each
variant can hold a distinct set of data.</p>
<p>In a dynamic programming language enums might not seem quite as useful, but it's
important for Rune to support them to have a level of feature parity with Rust.</p>
<p>Even so, in this section we'll explore some cases where enums are useful.</p>
<h2><a class="header" href="#the-option-enum" id="the-option-enum">The <code>Option</code> enum</a></h2>
<p>Rune has native support for <code>Option</code>, the same enum available in Rust that
allows you to represent data that can either be present with <code>Option::Some</code>, or
absent with <code>Option::None</code>.</p>
<pre><code class="language-rust noplaypen">use std::iter::range;

fn count_numbers(limit) {
    let limit = limit.unwrap_or(10);

    for n in range(0, limit) {
        println(`Count: {n}`);
    }
}

fn main() {
    println(&quot;First count!&quot;);
    count_numbers(None);

    println(&quot;Second count!&quot;);
    count_numbers(Some(2));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_7/count_numbers.rn
First count!
Count: 0
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
Count: 6
Count: 7
Count: 8
Count: 9
Second count!
Count: 0
Count: 1
== () (9.0745ms)
</code></pre>
<p>Using an <code>Option</code> allows us to easily model the scenario where we have an
optional function parameter, with a default fallback value.</p>
<p>In the next section we'll be looking into a control flow construct which gives
<code>Option</code> superpowers.</p>
<p>The try operator.</p>
<h1><a class="header" href="#try-operator" id="try-operator">Try operator</a></h1>
<p>The try operator (<code>?</code>) is a control flow operator which causes a function to
return early in case the value being tried over has a certain value.</p>
<p>For <code>Option</code>, this causes the function to return if it has the <code>Option::None</code>
variant.</p>
<pre><code class="language-rust noplaypen">fn checked_div_mod(a, b) {
    let div = a.checked_div(b)?;
    Some((div, a % b))
}

fn main() {
    if let Some((div, mod)) = checked_div_mod(5, 2) {
        println(`Result: {div}, {mod}`);
    }

    if let Some((div, mod)) = checked_div_mod(5, 0) {
        println(`Result: {div}, {mod}`);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/6/basic_try.rn
Result: 2, 1
== () (7.4912ms)
</code></pre>
<h1><a class="header" href="#generators" id="generators">Generators</a></h1>
<p>Generators are a convenient method for constructing functions which are capable
of suspending themselves and their state.</p>
<p>The simplest use case for generators is to create a kind of iterator, whose
state is stored in the generator function.</p>
<p>With this, we can create a fairly efficient generator to build fibonacci
numbers.</p>
<pre><code class="language-rust noplaypen">fn fib() {
    let a = 0;
    let b = 1;

    loop {
        yield a;
        let c = a + b;
        a = b;
        b = c;
    }
}

fn main() {
    let g = fib();

    while let Some(n) = g.next().await {
        dbg(n);

        if n &gt; 100 {
            break;
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/fib_generator.rn
0
1
1
2
3
5
8
13
21
34
55
89
144
== () (14.9441ms)
</code></pre>
<h2><a class="header" href="#advanced-generators-with-generatorstate" id="advanced-generators-with-generatorstate">Advanced generators with <code>GeneratorState</code></a></h2>
<p>Generators internally are a bit more complex than that.
The <code>next</code> function simply slates over some of that complexity to make simple
things easier to do.</p>
<p>The first thing to know is that <code>yield</code> itself can actually <em>produce</em> a value,
allowing the calling procedure to send values to the generator.</p>
<pre><code class="language-rust noplaypen">fn printer() {
    loop {
        let out = yield;
        dbg(out);
    }
}

fn main() {
    let printer = printer();
    printer.resume(1).await;
    printer.resume(&quot;John&quot;).await;
    printer.resume((1, 2, 3)).await;
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/send_values.rn
&quot;John&quot;
(1, 2, 3)
== () (883.2¬µs)
</code></pre>
<p>But wait, what happened to the first value we sent, <code>1</code>?</p>
<p>Well, generators don't run immediately, they need to be &quot;warmed up&quot; by calling
resume once.
At that point it runs the block prior to the first yield, we can see this by
instrumenting our code a little.</p>
<pre><code class="language-rust noplaypen">fn printer() {
    loop {
        println(&quot;waiting for value...&quot;);
        let out = yield;
        dbg(out);
    }
}

fn main() {
    let printer = printer();

    println(&quot;firing off the printer...&quot;);
    printer.resume(()).await;
    println(&quot;ready to go!&quot;);

    printer.resume(&quot;John&quot;).await;
    printer.resume((1, 2, 3)).await;
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/bootup.rn
</code></pre>
<p>Ok, so we understand how to <em>send</em> values into a generator.
But how do we <em>receive</em> them?</p>
<p>This adds a bit of complexity, since we need to pull out <code>GeneratorState</code>.
This enum has two variants: <code>Yielded</code> and <code>Complete</code>, and represents all the
possible states a generator can suspend itself into.</p>
<pre><code class="language-rust noplaypen">fn print_once() {
    let out = yield 1;
    dbg(out);
    2
}

fn main() {
    let printer = print_once();
    dbg(printer.resume(()).await);
    dbg(printer.resume(&quot;John&quot;).await);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/states.rn
Yielded(1)
&quot;John&quot;
Complete(2)
== () (712.7¬µs)
</code></pre>
<p>After the first call to resume, we see that the generator produced <code>Yielded(1)</code>.
This corresponds to the <code>yield 1</code> statement in the generator.</p>
<p>The second value we get is <code>Complete(2)</code>.
This corresponds to the <em>return value</em> of the generator.</p>
<p>Trying to resume the generator after this will cause the virtual machine to
error.</p>
<pre><code class="language-rust noplaypen">fn print_once() {
    yield 1
}

fn main() {
    let printer = print_once();
    dbg(printer);
    dbg(printer.resume(()).await);
    dbg(printer.resume(&quot;John&quot;).await);
    dbg(printer);
    dbg(printer.resume(()).await);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/error.rn
Generator { completed: false }
Yielded(1)
Complete(&quot;John&quot;)
Generator { completed: true }
error: virtual machine error
   ‚îå‚îÄ scripts/book/7/error.rn:11:9
   ‚îÇ
11 ‚îÇ     dbg(printer.resume(()).await);
   ‚îÇ         ^^^^^^^^^^^^^^^^^^^^^^^^ cannot resume generator that has completed
</code></pre>
<h1><a class="header" href="#asynchronous-programming" id="asynchronous-programming">Asynchronous programming</a></h1>
<p>Rune has first class support for Rust-like asynchronous programming.
In this section we'll be briefly covering what asynchronous programming is, and
how it applies to Rune as a dynamic programming language.</p>
<h2><a class="header" href="#what-is-it" id="what-is-it">What is it?</a></h2>
<p>Asynchronous code allows us to run multiple tasks concurrently, and work with
the result of those tasks.</p>
<p>A typical example would be if we want to perform multiple HTTP requests at once:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = http::get(&quot;https://google.com&quot;);
    let b = http::get(&quot;https://amazon.com&quot;);

    loop {
        let res = select {
            res = a =&gt; res?,
            res = b =&gt; res?,
        };

        match res {
            () =&gt; break,
            result =&gt; {
                println(`{result.status()}`);
            }
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/8/async_http.rn
200 OK
200 OK
== () (591.0319ms)
</code></pre>
<p>In the above code we send two requests <em>concurrently</em>. They are both processed
at the same time and we collect the result.</p>
<h2><a class="header" href="#select-blocks" id="select-blocks"><code>select</code> blocks</a></h2>
<p>A fundamental construct of async programming in Rune is the <code>select</code> block.
It enables us to wait on a set of futures at the same time.</p>
<p>A simple example of this is if we were to implement a simple request with a
timeout:</p>
<pre><code class="language-rust noplaypen">struct Timeout;

fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    println(`{result.status()}`);
    Ok(())
}

fn main() {
    if let Err(Timeout) = request(1000) {
        println(&quot;Request timed out!&quot;);
    }

    if let Err(Timeout) = request(4000) {
        println(&quot;Request timed out!&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/8/async_http_timeout.rn
200 OK
Request timed out!
== () (3.2231404s)
</code></pre>
<p>But wait, this is taking three seconds. We're not running the requests
concurrently any longer!</p>
<p>Well, while the request and the <em>timeout</em> is run concurrently, the <code>request</code>
function is run one at-a-time.</p>
<p>To fix this we need two new things: <code>async</code> functions and <code>.await</code>.</p>
<h2><a class="header" href="#async-functions" id="async-functions"><code>async</code> functions</a></h2>
<p><code>async</code> functions are just like regular functions, except that when called they
produce a <code>Future</code>.</p>
<p>In order to get the result of this <code>Future</code> it must be <code>.await</code>-ed.</p>
<pre><code class="language-rust noplaypen">use std::future;

struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    Ok(result)
}

fn main() {
    for result in future::join([request(1000), request(4000)]).await {
        match result {
            Ok(result) =&gt; println(`Result: {result.status()}`),
            Err(Timeout) =&gt; println(&quot;Request timed out!&quot;),
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/8/async_http_concurrent.rn
Result: 200 OK
Request timed out!
== () (2.0028603s)
</code></pre>
<p>If you've been using future in Rust, one thing immediately pops out to you.</p>
<p>We're using <code>.await</code> in a non-<code>async</code> function!</p>
<p>Well, in Rune the virtual machine already comes with a Runtime. Every function
therefore has the ability to <code>.await</code> a future, regardless of if the function
itself is async or not.</p>
<p>In fact, the whole Runtime is asynchronous, but that is for a future, much much
more advanced chapter!</p>
<h1><a class="header" href="#functions-and-closures" id="functions-and-closures">Functions and closures</a></h1>
<p>We've gone over functions before, and while incredibly useful there's a few more
tricks worth mentioning.</p>
<p>We'll also be talking about closures, an anonymous function with the ability to
<em>close over</em> its environment, allowing the function to use and manipulate things
from its environment.</p>
<h2><a class="header" href="#function-pointers" id="function-pointers">Function pointers</a></h2>
<p>Every function can be converted into a function pointer simply by referencing
its name without calling it.</p>
<p>This allows for some really neat tricks, like passing in a function which
represents the operation you want another function to use.</p>
<pre><code class="language-rust noplaypen">fn do_thing(op) {
    op(1, 2)
}

fn add(a, b) {
    a + b
}

fn sub(a, b) {
    a - b
}

fn main() {
    println(`{do_thing(add)}`);
    println(`{do_thing(sub)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/9/function_pointers.rn
Result: 3
Result: -1
== () (5.4354ms)
</code></pre>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<p>Closures are anonymous functions which closes over their environment.
This means that they capture any variables used inside of the closure, allowing
them to be used when the function is being called.</p>
<pre><code class="language-rust noplaypen">fn work(op) {
    op(1, 2)
}

fn main() {
    let n = 1;
    println(`Result: {work(|a, b| n + a + b)}`);
    println(`Result: {work(|a, b| n + a * b)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/9/basic_closure.rn
Result: 4
Result: 3
== () (5.4354ms)
</code></pre>
<blockquote>
<p>Hint: Closures which do not capture their environment are <em>identical</em> in
representation to a function.</p>
</blockquote>
<h1><a class="header" href="#functions-outside-of-the-vm" id="functions-outside-of-the-vm">Functions outside of the Vm</a></h1>
<p>Now things get <em>really</em> interesting.
Runestick, the virtual machine driving Rune, has support for passing function
pointers out of the virtual machine using the <code>FnPtr</code> type.</p>
<p>This allows you to write code that takes a function constructed in Rune, and use
it for something else.</p>
<p>Below we showcase this, with the help of the <code>rune!</code> macro from <code>rune-testing</code>.</p>
<pre><code class="language-rust noplaypen">use rune_testing::*;

fn main() -&gt; runestick::Result&lt;()&gt; {
    let fn_ptr: FnPtr = rune! {
        FnPtr =&gt; r#&quot;
        fn foo(a, b) {
            a + b
        }

        fn main() {
            foo
        }
        &quot;#
    };

    println!(&quot;{}&quot;, block_on(fn_ptr.call::&lt;(i64, i64), i64&gt;((1, 3)))?);
    println!(&quot;{}&quot;, block_on(fn_ptr.call::&lt;(i64, i64), i64&gt;((2, 6)))?);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example call_rune_fn
4
8
</code></pre>
<p>Note that these functions by necessity have to capture their entire context and
can take up quite a bit of space if you keep them around while cycling many
contexts or units.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
