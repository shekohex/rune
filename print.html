<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rune Programming Language</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="2_introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="3_getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="4_concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4_1_items_and_imports.html"><strong aria-hidden="true">4.1.</strong> Items and imports</a></li><li class="chapter-item expanded "><a href="4_2_variables.html"><strong aria-hidden="true">4.2.</strong> Variables and memory</a></li><li class="chapter-item expanded "><a href="4_3_control_flow.html"><strong aria-hidden="true">4.3.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="4_4_loops.html"><strong aria-hidden="true">4.4.</strong> Loops</a></li><li class="chapter-item expanded "><a href="4_5_pattern_matching.html"><strong aria-hidden="true">4.5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="4_6_template_strings.html"><strong aria-hidden="true">4.6.</strong> Template strings</a></li><li class="chapter-item expanded "><a href="4_7_instance_functions.html"><strong aria-hidden="true">4.7.</strong> Instance functions</a></li></ol></li><li class="chapter-item expanded "><a href="5_types.html"><strong aria-hidden="true">5.</strong> Rune types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_1_primitives.html"><strong aria-hidden="true">5.1.</strong> Primitive and reference types</a></li><li class="chapter-item expanded "><a href="5_2_vectors.html"><strong aria-hidden="true">5.2.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="5_3_objects.html"><strong aria-hidden="true">5.3.</strong> Objects</a></li><li class="chapter-item expanded "><a href="5_4_tuples.html"><strong aria-hidden="true">5.4.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="5_5_functions.html"><strong aria-hidden="true">5.5.</strong> Functions</a></li><li class="chapter-item expanded "><a href="5_6_structs.html"><strong aria-hidden="true">5.6.</strong> Structs</a></li><li class="chapter-item expanded "><a href="5_7_enums.html"><strong aria-hidden="true">5.7.</strong> Enums</a></li></ol></li><li class="chapter-item expanded "><a href="6_try_operator.html"><strong aria-hidden="true">6.</strong> Try operator</a></li><li class="chapter-item expanded "><a href="7_generators.html"><strong aria-hidden="true">7.</strong> Generators</a></li><li class="chapter-item expanded "><a href="8_async.html"><strong aria-hidden="true">8.</strong> Asynchronous programming</a></li><li class="chapter-item expanded "><a href="9_functions_closures.html"><strong aria-hidden="true">9.</strong> Functions and closures</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rune Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<blockquote>
<p>&quot;Why am I making a programming language?&quot;</p>
</blockquote>
<p>This question keeps rolling around in my head as I'm typing out the code that is
slowly shaping into <em>Rune</em>. Programming is like magic. You imagine it in your
mind, write it out, and there it is. Doing <em>stuff</em> which wasn't being done
before.</p>
<p>Truth be told, I'm scared that people will tell me that I'm wasting my time.
This has already been done, or &quot;Why not just use X?&quot;. An thing so glaringly
obvious that all of my efforts are wasted.</p>
<p>But you actually don't need a reason. It can simply be for The <a href="https://en.wikipedia.org/wiki/The_Joy_of_Painting">Joy of
Creating</a>, and then it's just you spending your own time as a hobby. No harm
done. But I want to talk about why I'm making Rune beyond just for fun. So I'm
dedicating this foreword to it. Because I want others to benefit from this I'm
obligated to describe why it might matter to them.</p>
<p>So here's why I started making a new programming language.</p>
<h2><a class="header" href="#the-other-project" id="the-other-project">The other project</a></h2>
<p>I've spent a lot of effort working on <a href="https://github.com/udoprog/OxidizeBot">OxidizeBot</a>, a Twitch bot that streamers
can use to add commands and other interactive things in their chat. I built it
for myself while streaming, but I'm also a generaliser. When adding features I
always spend way to much time tinkering with it. Making it as generic as
possible, so it can solve more than just one problem. And when it's a personal
project, I just don't care about being efficient. I care much more deeply about
doing things the right way.</p>
<p>...</p>
<p>Ok, I <em>sometimes</em> do that professionally as well. But a working environment is
much more constrained.</p>
<p>Anyway, that means the bot isn't incredibly specialized to my needs and can be
used by others. It's starting to see a little bit of that use now, which is a
lot of fun. I made something which helps people do something cool.</p>
<p>All the commands in the bot are written in <a href="https://rust-lang.org">Rust</a>, and <a href="https://github.com/udoprog/OxidizeBot/tree/master/bot/src/module">compiled straight into
the bot</a>. This is nice because Rust is an incredible language. But Rust is also
complex. Not nedlessly mind you. In my view it's complex because it decided to
tackle <em>really hard problems</em>. And that usually comes with a <a href="https://en.wikipedia.org/wiki/Waterbed_theory">base level of
complexity</a> that it's very hard to get rid of.</p>
<p>But it's still tricky enough that streamers who have very little programming
experience struggle getting up and running*. I wanted them to be able to write
their own commands. Ones they could just drop into a folder and <em>presto</em> -
you're up and running.</p>
<blockquote>
<p>*: To this day I've tutored two of these streamers who were interested in
learning Rust to write their own commands.</p>
</blockquote>
<p>For this reason I started looking into dynamic programming languages. Ones that
could be embedded into an existing Rust application with little to no effort.
That seemlessly integrates with its environment.</p>
<p>Type systems are the best thing since sliced bread. But type systems are also
one of these complexities which can get in the way of being productive if you're
not familiar with them. Not everyone wants to learn how to climb before they can
walk.</p>
<p>So a number of candidates came up, and the one that stood out the most to me was
<a href="https://github.com/jonathandturner/rhai">Rhai</a>.</p>
<p>So why is Rhai awesome? It has Rust-like syntax. The runtime is fully written in
mostly safe Rust, and can be easily embedded. Hooking up Rust functions is a
piece of cake.</p>
<p>But Rhai has a set of features and design constraints which didn't <em>exactly</em>
scratch my itch. And the more I used it, the more I thought about things that
could be changed or added. <a href="https://github.com/jonathandturner/rhai/commits?author=udoprog">I contributed a bit to the project</a>. But it started
to dawn on me that Rhai's approach wasn't exactly what I wanted. There's nothing
wrong with this. The authors of Rhai have specific ideas of what they wanted to
accomplish which lends itself to one design.</p>
<p>While I believe that it's feasible to push Rhai in a different direction, I also
think the project would emerge looking much different on the other side. So I
wanted a fresh slate to find my own compromises. To discover more freely what
works and doesn't work well.</p>
<p>When I started I had the following rough goals in mind:</p>
<ul>
<li>Performance should be comparable to Lua and Python (And eventually LuaJIT when we have cranelift).</li>
<li>Scripts should compile quickly.</li>
<li>Rune should feel like Rust without types.</li>
<li>Be as good as Rhai when it comes to integrating with native Rust.</li>
<li>Make sure Rune's internals will work well through C bindings.</li>
<li>A lightweight runtime that is strictly singlethreaded*.</li>
</ul>
<blockquote>
<p>*: If this feels like a step backwards, don't worry too much. We can still
have concurrency and threads using async code.</p>
</blockquote>
<p>Rune is now in a state where I want people to poke at it. Not <em>too</em> hard mind
you, because it's still very early days. So don't use it in anything user-facing
or security critical. A miscompilation will cause the wrong closure to be
called. You know, the one which <em>doesn't</em> do all your fancy security checks üòÖ.</p>
<p>But the more poking and prodding people do, the more issues will be found. Every
solved issue brings Rune one step close to being production ready.</p>
<p>I really want to thank Jonathan Turner and the Rhai project. They have been a
huge inspirationa to me. If you need an embedded scripting engine that is more
mature right now than <em>Rune</em>, please take <em>Rhai</em> for a spin.</p>
<p>‚Äî John-John Tedro</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome the <em>The Rune Programming Language</em>, a reference guide to Rune.</p>
<p>Rune is an embeddable dynamic programming language that runs on a stack machine.</p>
<p>The goal of Rune is to reimagine Rust as a dynamic programming language.
Trying to mimic as many concepts as possible, and remixing ones which do not
translate into something which works well and feels familiar.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>The first thing you need to learn about in Rune is the <code>dbg</code> function. This is
used to &quot;debug&quot; the values provided to it, and can be used to understand what
values variables have.</p>
<pre><code class="language-rust noplayground">fn main() {
    let a = [1, 2, 3];
    let b = '‰ªä';

    dbg(a);
    dbg(b);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3/dbg.rn
[1, 2, 3]
&quot;Hello World&quot;
== () (1.0864ms)
</code></pre>
<p>The default <code>dbg</code> implementation outputs information on its arguments to stdout.
But its exact behavior can differ depending on how the environment is
configured. When Rune is embedded into a larger application it might for example
be more suitable to output to a log file.</p>
<p>Rune also provides <code>print</code> and <code>println</code> functions which can be used to write
directly to stdout, but these cannot be relied on to be present to the same
degree as <code>dbg</code>. But for our purposes we will be using <code>rune-cli</code>, which has all
of these modules installed. This is also what was used to run the above code.</p>
<p>So for a more format introduction, here is <code>&quot;Hello World&quot;</code> in Rune:</p>
<pre><code class="language-rust noplaypen">
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/3/hello_world.rn
&quot;Hello World&quot;
== () (1.0864ms)
</code></pre>
<p>At the end of the script you see this rather odd looking line:</p>
<pre><code class="language-text">== () (412.2¬µs)
</code></pre>
<p>This simply means that the script evaluated to a unit, or a <code>()</code>.
And that the execution took <code>412</code> microseconds.</p>
<blockquote>
<p>Cool Hint:
Any function that doesn't have a return value returns a unit.</p>
</blockquote>
<p>So now you know how to run Rune scripts. Well done!</p>
<p>Let's move on to the next chapter.</p>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<p>This chapter covers common concepts that appear in almost all programming
languages, and how they work in Rune.</p>
<p>Hopefully these should be familiar to anyone who's used imperative programming
languages before. We'll try to take each concept and describe how they work with
examples, one at a time.</p>
<h1><a class="header" href="#items-and-imports" id="items-and-imports">Items and imports</a></h1>
<p>Everything in Rune has a unique name. Every function and type. This name is what
identifies that thing, and is called its <em>item</em>. Rune performs compile time
checks to make sure that every item we try to use actually exists.</p>
<p>The following are examples of items in Rune:</p>
<ul>
<li><code>std::result::Result</code></li>
<li><code>std::test::assert</code></li>
</ul>
<p>The first refers to the <code>Result</code> enum, and the second is the <code>assert</code> function.
They both live within their corresponding <code>std</code> module. <code>Result</code> is a bit
special even, since it's part of the <em>prelude</em>, allowing us to use it without
importing it. But what about <code>assert</code>?</p>
<p>If we wanted to use <code>assert</code> we would have to import it first with a <code>use</code>
statement:</p>
<pre><code class="language-rust noplayground">use std::test::assert;

fn main() {
    assert(1 &lt; 2, &quot;one is less than two&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/example_import.rn
== () (34.6¬µs)
</code></pre>
<p>Trying to use an item which doesn't exist results in a compile error:</p>
<pre><code class="language-rust noplayground">fn main() {
    let foo = Foo::new();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_1/missing_item.rn
error: compile error
  ‚îå‚îÄ scripts/book/4_1/missing_item.rn:2:15
  ‚îÇ
2 ‚îÇ     let foo = Foo::new();
  ‚îÇ               ^^^^^^^^^^ `Foo::new` is not a function
</code></pre>
<p>Every item used in a Rune program must be known at compile time. This is one of
the guarantees a Rune scripts are required to fulfill. It's otherwise typical
for dynamic programming languages not to require this. But while Rune is also a
dynamic language, it tries to be as helpful as possible and avoid patterns which
might be a source for bugs.</p>
<h1><a class="header" href="#variables-and-memory" id="variables-and-memory">Variables and memory</a></h1>
<p>Variables in Rune are defined using the <code>let</code> keyword. In contrast to Rust, all
variables in Rune are mutable and can be changed at any time.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let x = 5;
    println(`The value of x is: {x}`);
    x = 6;
    println(`The value of x is: {x}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/variables.rn
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Rune is a memory safe language. Regardless of what you write in a Rune scripts,
we maintain the same memory safety guarantees as safe Rust. This is accomplished
in Rune through reference counting.</p>
<h2><a class="header" href="#reference-counting-and-ownership" id="reference-counting-and-ownership">Reference counting and ownership</a></h2>
<p>In Rune, <a href="5_1_primitives.html">unless a value is <code>Copy</code></a>, they are reference
counted and can be used simultaneously at multiple locations. In other words
this means that they have <em>shared ownership</em>. Every variable that points to that
value therefore points to <em>the same instance</em> of that value.</p>
<p>We can see how this works by sharing and mutating one object across two
variables:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`{object.field}`);
    object2.field = 2;

    // Note: we changed `object2`, but read out `object`
    println(`{object.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/shared_ownership.rn
1
2
== () (913.4¬µs)
</code></pre>
<p>This can cause issues if we call an external function which expects to take
ownership of its arguments. We say that functions like these <em>move</em> their
argument, and if we try to use a variable which has been move,d an error will be
raised in the virtual machine.</p>
<blockquote>
<p>Note: Below we use the <code>drop</code> function, which is a built-in function that will
take its argument and free it.</p>
</blockquote>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);
    println(`field: {object.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/take_argument.rn
field: 1
error: virtual machine error
  ‚îå‚îÄ scripts/book/4_2/take_argument.rn:6:22
  ‚îÇ
6 ‚îÇ     println(`field: {object.field}`);
  ‚îÇ                      ^^^^^^^^^^^^ failed to access value: cannot read, value is moved
</code></pre>
<p>If you need to, you can test if a variable is still accessible for reading with
<code>is_readable</code>, and for writing with <code>is_writable</code>. These are both imported in
the prelude. An object which is writable is also <em>movable</em>, and can be provided
to functions which needs to move the value, like <code>drop</code>.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);

    if is_readable(object) {
        println(`field: {object.field}`);
    } else {
        println(&quot;object is no longer readable üò¢&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_2/is_readable.rn
field: 1
object is no longer readable üò¢
== () (943.8¬µs)
</code></pre>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<p>Rune supports your typical forms of control flow.</p>
<h2><a class="header" href="#return-keyword" id="return-keyword"><code>return</code> Keyword</a></h2>
<p>The <code>return</code> keyword allows for returning from the current function.
If specified without an argument, the function will return a unit <code>()</code>.</p>
<p>The last statement in a function is known as an <em>implicit return</em>, and will be
what the function returns by default unless a <code>return</code> is specified.</p>
<pre><code class="language-rust noplaypen">fn foo(n) {
    if n &lt; 1 {
        return &quot;less than one&quot;;
    }

    &quot;something else&quot;
}

fn main() {
    println(foo(0)) // =&gt; outputs: &quot;less than one&quot;
    println(foo(10)); // =&gt; outputs: &quot;something else&quot;
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/numbers_game.rn
less than one
something else
== () (3.8608ms)
</code></pre>
<h2><a class="header" href="#if-expressions" id="if-expressions"><code>if</code> Expressions</a></h2>
<p>If expressions allow you to provide a condition with one or more code branches.
If the condition is <code>true</code>, the provided block of code will run.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;The number *is* smaller than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/conditional.rn
The number *is* smaller than 5
== () (5.108ms)
</code></pre>
<p>Optionally, we can add another branch under <code>else</code>, which will execute in case
the condition is false.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else {
        println(&quot;the number is 5 or bigger&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/conditional_else.rn
the number is smaller than 5
== () (196.1¬µs)
</code></pre>
<p>We can also add an arbitrary number of <code>else if</code> branches, which allow us to
specify many different conditions.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else if number == 5 {
        println(&quot;the number is exactly 5&quot;);
    } else {
        println(&quot;the number is bigger than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/conditional_else_ifs.rn
the number is smaller than 5
== () (227.9¬µs)
</code></pre>
<p>Do note however that if you have <em>many</em> conditions, it might be cleaner to use
a <code>match</code>.</p>
<p>This will be covered in a later section, but here is a sneak peek:</p>
<pre><code class="language-rust noplaypen">fn main() {
    let number = 3;

    match number {
        n if n &lt; 5 =&gt; {
            println(&quot;the number is smaller than 5&quot;);
        }
        5 =&gt; {
            println(&quot;the number is exactly 5&quot;);
        }
        n =&gt; {
            println(&quot;the number is bigger than 5&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_3/first_match.rn
the number is smaller than 5
== () (124.2¬µs)
</code></pre>
<h1><a class="header" href="#loops" id="loops">Loops</a></h1>
<p>Loops are a fundamental building block common to many programming languages.
This is no exception in Rune.
Loops allow you to execute a block of code until a specific condition is
reached, which can be a powerful tool for accomplishing programming tasks.</p>
<h2><a class="header" href="#break-keyword" id="break-keyword"><code>break</code> Keyword</a></h2>
<p>Every loop documented in this section can be <em>terminated early</em> using the
<code>break</code> keyword.</p>
<p>When Rune encounters a break, it will immediately jump out of the loop it is
currently in and continue running right after it.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let value = 0;

    while value &lt; 100 {
        if value &gt;= 50 {
            break;
        }

        value = value + 1;
    }

    println(`The value is {value}`); // =&gt; The value is 50
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/while_loop.rn
The value is 50
== () (501.1¬µs)
</code></pre>
<h2><a class="header" href="#loop-expressions" id="loop-expressions"><code>loop</code> Expressions</a></h2>
<p>The <code>loop</code> keywords builds the most fundamental form of loop in Rune.
One that repeats unconditionally forever, until it is exited using another
control flow operator like a <code>break</code> or a <code>return</code>.</p>
<pre><code class="language-rust noplaypen">use time::Duration;

async fn main() {
    loop {
        println(&quot;loop forever&quot;);
        time::delay_for(Duration::from_secs(1)).await;
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/loop_forever.rn
Hello forever!
Hello forever!
Hello forever!
...
</code></pre>
<blockquote>
<p>Hint: If you want this one to end, you're gonna have to kill it with <code>CTRL+C</code>.</p>
</blockquote>
<p>We're also using an asynchronous function called <code>delay_for</code> above to avoid
spamming our terminals too much.
Well talk more about these in a later section.</p>
<p>When broken out of, loops produce the value provided as an argument to the
<code>break</code> keyword.
By default, this is simply a unit <code>()</code>.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let counter = 0;

    let total = loop {
        counter = counter + 1;

        if counter &gt; 10 {
            break counter;
        }
    };

    println(`The final count is: {total}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_4/loop_break.rn
The final count is: 11
== () (281.5¬µs)
</code></pre>
<h1><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h1>
<p>In this section we will be discussing <em>Pattern Matching</em>.</p>
<p>Pattern matching is a flexible mechanism that allows for validating the
structure and type of the argument, while also destructing it to give easy
access to what you need.</p>
<p>Below are some examples of its common uses to match on branch conditions:</p>
<pre><code class="language-rust noplaypen">fn match_input(n) {
    match n {
        1 =&gt; println(&quot;The number one.&quot;),
        n if n is int =&gt; println(`Another number: {n}.`),
        [1, 2, n, ..] =&gt; println(`A vector starting with one and two, followed by {n}.`),
        &quot;one&quot; =&gt; println(&quot;One, but this time as a string.&quot;),
        _ =&gt; println(&quot;Something else. Can I go eat now?&quot;),
    }
}

fn main() {
    match_input(1);
    match_input(2);
    match_input([1, 2, 42, 84]);
    match_input(&quot;one&quot;);
    match_input(#{field: 42});
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_5/big_match.rn
The number one.
Another number: 2.
A vector starting with one and two, followed by 42.
One, but this time as a string.
Something else. Can I go eat now?
== () (5.691ms)
</code></pre>
<p>We will be covering each of these variants in detail in the coming sections.</p>
<h2><a class="header" href="#matching-literals" id="matching-literals">Matching Literals</a></h2>
<p>Literals are the simplest form of matching. Where we test if the branch is
exactly equal to a literal.</p>
<p>Literals take a number of form:</p>
<ul>
<li>A literal unit, simply <code>()</code>.</li>
<li>A literal boolean, like <code>true</code> or <code>false</code>.</li>
<li>A literal character, like <code>'a'</code> or <code>'„ÅÇ'</code>.</li>
<li>A literal integer, like <code>42</code>.</li>
<li>A string, like <code>&quot;Steven Universe&quot;</code>.</li>
<li>A vector, like the numbers <code>[4, 8, 15, 16, 23, 42]</code> or the empty vector <code>[]</code>.</li>
<li>A tuple, like <code>(&quot;Steven Universe&quot;, 42)</code>.</li>
<li>An object, like the numbers <code>{&quot;name&quot;: &quot;Steven Universe&quot;}</code> or the empty <code>{}</code>.</li>
</ul>
<p>Finally, literals can be <em>any</em> combination of the above.
Even <code>{&quot;items&quot;: [&quot;Sword&quot;, &quot;Bow&quot;, &quot;Axe&quot;]}</code> is a literal that can be matched over.</p>
<h2><a class="header" href="#match-bindings" id="match-bindings">Match Bindings</a></h2>
<p>In a pattern, every literal value can also be replaced with an ignore directive
or a binding.</p>
<p>The ignore directive looks like an underscore <code>_</code>, which tells rune to <em>ignore</em>
the value, allowing it to have any value.</p>
<pre><code class="language-rust noplaypen">fn test_ignore(vector) {
    match vector {
        [_, 2] =&gt; println(&quot;Second item in vector is 2.&quot;),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_5/ignore.rn
Second item in vector is 2.
== () (281.3¬µs)
</code></pre>
<p>In contrast to ignoring, we cal also <em>bind</em> the value to a variable that is then
in scope of the match arm.</p>
<pre><code class="language-rust noplaypen">fn test_ignore(vector) {
    match vector {
        [_, b] =&gt; println(`Second item in vector is {b}.`),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_5/bind.rn
Second item in vector is 2.
== () (6.25ms)
</code></pre>
<p>Here are some more examples:</p>
<ul>
<li><code>[_, a, b]</code> which will ignore the first, but then capture the second and third
element in the vector.</li>
<li><code>{&quot;name&quot;: name}</code> will capture the <code>name</code> value out of the specified object.</li>
</ul>
<p>Finally we can also add the sequence <code>..</code> to ask Rune to <em>ignore</em> any additional
values in a collection that might be present when matching a vector or an
object.</p>
<pre><code class="language-rust noplaypen">fn describe_car(car) {
    match car {
<span class="boring">        {&quot;make&quot;: year, ..} if year &lt; 1950 =&gt; &quot;What, where did you get that?&quot;,
</span><span class="boring">        {&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: year, ..} if year &gt;= 2000 =&gt; &quot;Pretty fast!&quot;,
</span>        _ =&gt; &quot;Can't tell üòû&quot;,
    }
}

fn main() {
    println(describe_car(#{&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: 2000}));
    println(describe_car(#{&quot;model&quot;: &quot;Honda&quot;, &quot;make&quot;: 1980}));
    println(describe_car(#{&quot;model&quot;: &quot;Volvo&quot;, &quot;make&quot;: 1910}));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_5/fast_cars.rn
Pretty fast!
Can't tell üòû
What, where did you get that?
== () (5.3533ms)
</code></pre>
<h1><a class="header" href="#template-strings" id="template-strings">Template strings</a></h1>
<p>If you've been paying attention on previous sections you might have seen odd
looking strings like <code>`Hello {name}`</code>. These are called <em>template strings</em>,
and allow use to conveniently build strings using variables from the
environment.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let age = 30;
    println(`I am {age} years old!`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_6/basic_template.rn
I am 30 years old!
== () (4.5678ms)
</code></pre>
<p>Template strings are accelerated by the Vm, each argument uses a <em>display
protocol</em> and it can be a very efficient to build complex strings out of it.</p>
<h2><a class="header" href="#the-string_display-protocol" id="the-string_display-protocol">The <code>STRING_DISPLAY</code> protocol</a></h2>
<p>The <code>STRING_DISPLAY</code> protocol is a function that can be implemented by any
<em>external</em> type which allows it to be used in a template string.</p>
<p>It expects a function with the signature <code>fn(&amp;self, buf: &amp;mut String) -&gt; fmt::Result</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Write as _;

#[derive(Debug)]
pub struct StatusCode {
    inner: u32,
}

impl StatusCode {
    fn display(&amp;self, buf: &amp;mut String) -&gt; fmt::Result {
        write!(buf, &quot;{}&quot;, self.inner)
    }
}

pub fn module() -&gt; Result&lt;runestick::Module, runestick::ContextError&gt; {
    let mut module = runestick::Module::new(&amp;[&quot;http&quot;]);
    module.inst_fn(runestick::STRING_DISPLAY, StatusCode::display)?;
    Ok(module)
}
<span class="boring">}
</span></code></pre></pre>
<p>This is what allows status codes to be formatted into template strings, any
types which do not implement this protocol will fail to run.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let vec = [1, 2, 3];
    println(`{vec}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_6/not_a_template.rn
error: virtual machine error
  ‚îå‚îÄ scripts/book/4_6/not_a_template.rn:3:13
  ‚îÇ
3 ‚îÇ     println(`{vec}`);
  ‚îÇ             ^^^^^^^ `vector` does not implement the `string_display` protocol
</code></pre>
<h1><a class="header" href="#instance-functions" id="instance-functions">Instance functions</a></h1>
<p>Instance functions are functions that are associated to a specific type of
variable. When called they take the form <code>value.foo()</code>, where the <em>instance</em>
is the first part <code>value</code>. And the <em>instance function</em> is <code>foo()</code>.</p>
<p>These are a bit special in Rune. Since Rune is a dynamic programming language we
can't tell at compile time which instance any specific <code>value</code> can be. So
instance functions must be looked up at runtime.</p>
<pre><code class="language-rust noplayground">struct Foo;

impl Foo {
    fn new() {
        Foo
    }
}

fn main() {
    let foo = Foo::new();
    foo.bar();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/4_7/missing_instance_fn.rn
error: virtual machine error
   ‚îå‚îÄ scripts/book/4_7/missing_instance_fn.rn:11:5
   ‚îÇ
11 ‚îÇ     foo.bar();
   ‚îÇ     ^^^^^^^^^ missing instance function `0xfb67fa086988a22d` for `type(0xc153807c3ddc98d7)``
</code></pre>
<blockquote>
<p>Note: The error is currently a bit nondescript. But in the future we will be
able to provide better diagnostics by adding debug information.</p>
</blockquote>
<p>What you're seeing above are type and function hashes. These uniquely identify
the item in the virtual machine and is the result of a deterministic computation
based on its item. So the hash for the item <code>Foo::new</code> will always be the same.</p>
<p>In Rust, we can calculate this hash using <code>Item</code> and <code>Hash::function</code> method:</p>
<pre><code class="language-rust noplayground">{{#include ../../crates/rune-testing/examples/function_hash}}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example function_hash
0xb5dc92ab43cb37d9
</code></pre>
<p>The exact implementation of the hash function is currently not defined, but will
be stabilized and documented in a future release.</p>
<h2><a class="header" href="#defining-instance-functions-in-rust" id="defining-instance-functions-in-rust">Defining instance functions in Rust</a></h2>
<p>Native instance functions are added to a runtime environment using the
<a href="https://docs.rs/runestick/0.5.3/runestick/struct.Module.html#method.inst_fn"><code>Module::inst_fn</code></a> and <a href="https://docs.rs/runestick/0.5.3/runestick/struct.Module.html#method.async_inst_fn"><code>Module::async_inst_fn</code></a> functions. The type is
identified as the first argument of the instance function, and must be a type
registered in the module using <a href="https://docs.rs/runestick/0.5.3/runestick/struct.Module.html#method.ty"><code>Module::ty</code></a>.</p>
<pre><code class="language-rust noplayground">use rune::{termcolor, Runtime};
use runestick::{Context, FromValue, Hash, Item, Module};
use std::io::Write as _;

fn divide_by_three(value: i64) -&gt; i64 {
    value / 3
}

#[tokio::main]
async fn main() -&gt; runestick::Result&lt;()&gt; {
    let mut my_module = Module::new(&amp;[&quot;mymodule&quot;]);
    my_module.inst_fn(&quot;divide_by_three&quot;, divide_by_three)?;

    let mut context = Context::with_default_modules()?;
    context.install(&amp;my_module)?;

    let mut runtime = Runtime::with_context(context);

    let result = runtime.load_source(
        String::from(&quot;test&quot;),
        String::from(
            r#&quot;
            fn call_instance_fn(number) {
                number.divide_by_three()
            }
            &quot;#,
        ),
    );

    let file_id = match result {
        Ok(file_id) =&gt; file_id,
        Err(e) =&gt; {
            let mut writer = termcolor::StandardStream::stderr(termcolor::ColorChoice::Never);
            writeln!(writer, &quot;failed to load source: {}&quot;, e)?;
            runtime.emit_diagnostics(&amp;mut writer)?;
            return Ok(());
        }
    };

    let vm = runtime.unit_vm(file_id).unwrap();

    let output = vm
        .call_function(Hash::type_hash(Item::of(&amp;[&quot;call_instance_fn&quot;])), (33i64,))?
        .async_complete()
        .await?;

    let output = i64::from_value(output)?;
    println!(&quot;output: {}&quot;, output);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example custom_instance_fn
output: 11
</code></pre>
<p>For more example on how Modules can be used you can have a look at the source
for the <a href="https://github.com/rune-rs/rune/tree/master/crates/rune-modules"><code>rune-modules</code></a> crate.</p>
<h1><a class="header" href="#rune-types" id="rune-types">Rune types</a></h1>
<p>Types in Rune are identified uniquely by their <em>item</em>. An item path is a
scope-separated identifier, like <code>std::float</code>. This particular item identifiers
a type.</p>
<p>These items can be used to perform basic type checking using the <code>is</code> and <code>is not</code> operations, like this:</p>
<pre><code class="language-rust noplaypen">use std::test::assert;

fn main() {
    assert(() is unit, &quot;units should be units&quot;);
    assert(true is bool, &quot;bools should be bools&quot;);
    assert('a' is char, &quot;chars should be chars&quot;);
    assert(b'a' is byte, &quot;bytes should be bytes&quot;);
    assert(42 is int, &quot;integers should be integers&quot;);
    assert(42.1 is float, &quot;floats should be floats&quot;);
    assert(&quot;hello&quot; is String, &quot;strings should be strings&quot;);
    assert(#{&quot;hello&quot;: &quot;world&quot;} is Object, &quot;objects should be objects&quot;);
    assert([&quot;hello&quot;, &quot;world&quot;] is Vec, &quot;vectors should be vectors&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/types.rn
== () (120¬µs)
</code></pre>
<p>Conversely, the type check would fail if you're providing a value which is not
of that type.</p>
<pre><code class="language-rust noplaypen">use std::test::assert;

fn main() {
    assert([&quot;hello&quot;, &quot;world&quot;] is String, &quot;vectors should be strings&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/bad_type_check.rn
error: virtual machine error
  ‚îå‚îÄ scripts/book/5/bad_type_check.rn:4:5
  ‚îÇ
4 ‚îÇ     assert([&quot;hello&quot;, &quot;world&quot;] is String, &quot;vectors should be strings&quot;);
  ‚îÇ     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ panicked `assertion failed `vectors should be strings``
</code></pre>
<p>This gives us insight at runtime which type is which, and allows rune scripts to
make decisions depending on what type a value has.</p>
<pre><code class="language-rust noplaypen">fn dynamic_type(n) {
    if n is String {
        &quot;n is a String&quot;
    } else if n is Vec {
        &quot;n is a vector&quot;
    } else {
        &quot;n is unknown&quot;
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/type_check.rn
n is a String
n is a vector
n is unknown
== () (1.0544ms)
</code></pre>
<p>A tighter way to accomplish this would be by using pattern matching. A mechanism
especially suited for many conditional branches. Especially when the branches
are different types or variants in an enum.</p>
<pre><code class="language-rust noplaypen">fn dynamic_type(n) {
    match n {
        n if n is String =&gt; &quot;n is a String&quot;,
        n if n is Vec =&gt; &quot;n is a vector&quot;,
        _ =&gt; &quot;n is unknown&quot;,
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5/type_check_patterns.rn
n is a String
n is a vector
n is unknown
== () (1.0341ms)
</code></pre>
<h1><a class="header" href="#primitive-and-reference-types" id="primitive-and-reference-types">Primitive and reference types</a></h1>
<p>Primitives are values stored immediately on the stack. In Rust terminology,
these types are <code>Copy</code>, so reassigning them to different values will create
distinct <em>copies</em> of the underlying value.</p>
<p>The primitives available in Rune are:</p>
<ul>
<li>the unit <code>()</code>.</li>
<li>booleans, <code>true</code> and <code>false</code>.</li>
<li>bytes, like <code>b'\xff'</code>.</li>
<li>characters, like <code>'‰ªä'</code>.</li>
<li>integers, like <code>42</code>.</li>
<li>floats, like <code>3.1418</code>.</li>
<li>static strings.</li>
<li>types.</li>
</ul>
<p>You can see that these bytes are <code>Copy</code> when assigning them to a different
variable, because a separate copy of the variable will be used.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = 1;
    let b = a;
    a = 2;
    println(`{a}`);
    println(`{b}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_1/copy.rn
2
1
== () (691.3¬µs)
</code></pre>
<p>Other types like <em>strings</em> are stored by reference on the stack. Assigning them
to a different variable will only <em>copy their reference</em>, but they still point
to the same underlying data.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let a = String::from_str(&quot;Hello&quot;);
    let b = a;
    a.push_str(&quot; World&quot;);
    println(a);
    println(b);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_1/primitives.rn
Hello World
Hello World
== () (9.7406ms)
</code></pre>
<h1><a class="header" href="#vectors" id="vectors">Vectors</a></h1>
<p>A vector is a native data structure of Rune which is a dynamic list of values. A
vector isn't typed, and can store <em>any</em> rune values.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = [&quot;Hello&quot;, 42];

    dbg(values[0]);
    dbg(values.1); // items be accessed like tuples fields.

    for v in values {
        dbg(v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_2/vectors.rn
&quot;Hello&quot;
42
&quot;Hello&quot;
42
== () (5.0674ms)
</code></pre>
<p>As you can see, you can iterate over a vector because it implements the iterator
protocol. It is also possible to create and use an iterator manually using
<code>Vec::iter</code>, giving you more control over it.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = [&quot;Hello&quot;, 42];

    for v in values.iter().rev() {
        dbg(v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_2/vectors_rev.rn
42
&quot;Hello&quot;
== () (2.9116ms)
</code></pre>
<h2><a class="header" href="#using-vectors-from-rust" id="using-vectors-from-rust">Using vectors from Rust</a></h2>
<p>Vectors are represented externally as the standard <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>.</p>
<pre><code class="language-rust noplaypen">use rune_testing::{run, Result};

fn main() -&gt; Result&lt;()&gt; {
    let input: Vec&lt;i64&gt; = vec![1, 2, 3, 4];

    let output: Vec&lt;i64&gt; = run(
        &amp;[&quot;calc&quot;],
        (input,),
        r#&quot;
        fn calc(input) {
            let output = 0;

            for value in input {
                output += value;
            }

            [output]
        }
        &quot;#,
    )?;

    println!(&quot;{:?}&quot;, output);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example vector
[10]
</code></pre>
<p>If you have a vector which have values of non-uniform types, you can use 
<a href="https://docs.rs/runestick/0/runestick/struct.VecTuple.html"><code>VecTuple</code></a> to deal with them.</p>
<pre><code class="language-rust noplaypen">use rune_testing::{run, Result};
use runestick::VecTuple;

fn main() -&gt; Result&lt;()&gt; {
    let input: VecTuple&lt;(i64, String)&gt; = VecTuple::new((1, String::from(&quot;Hello&quot;)));

    let output: VecTuple&lt;(i64, String)&gt; = run(
        &amp;[&quot;calc&quot;],
        (input,),
        r#&quot;
        fn calc(input) {
            let a = input[0] + 1;
            let b = `{input[1]} World`;
            [a, b]
        }
        &quot;#,
    )?;

    let VecTuple((a, b)) = output;
    println!(&quot;({:?}, {:?})&quot;, a, b);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example vec_tuple
(2, &quot;Hello World&quot;)
</code></pre>
<h1><a class="header" href="#objects" id="objects">Objects</a></h1>
<p>Objects are anonymous maps, which support defining and using arbitrary string
keys.</p>
<pre><code class="language-rust noplaypen">use std::test::assert;

fn main() {
    let values = #{};
    values[&quot;first&quot;] = &quot;bar&quot;;
    values[&quot;second&quot;] = 42;

    dbg(values[&quot;first&quot;]);
    dbg(values.second); // items be accessed like struct fields.

    if let Some(key) = values.get(&quot;not a key&quot;) {
        dbg(key);
    } else {
        println(&quot;key did not exist&quot;);
    }

    for entry in values {
        dbg(entry);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_3/objects.rn
&quot;bar&quot;
42
key did not exist
(&quot;second&quot;, 42)
(&quot;first&quot;, &quot;bar&quot;)
== () (3.3527ms)
</code></pre>
<p>These are useful because they allow their data to be specified dynamically,
which is exactly the same use case as storing unknown JSON.</p>
<p>One of the biggest motivations for <em>Rune</em> to have anonymous objects is so that
we can natively data with unknown structure.</p>
<pre><code class="language-rust noplaypen">async fn get_commits(repo, limit) {
    let limit = limit.unwrap_or(10);

    let client = http::Client::new();
    let request = client.get(`https://api.github.com/repos/{repo}/commits`).await?;
    let response = request.header(&quot;User-Agent&quot;, &quot;Rune&quot;).send().await?;
    let text = response.text().await?;
    let json = json::from_string(text)?;

    let commits = Vec::new();
    let count = 0;

    for entry in json {
        commits.push(entry.sha);

        if count &gt;= limit {
            break;
        }

        count += 1;
    }

    commits
}

async fn main() {
    for commit in get_commits(&quot;rune-rs/rune&quot;, Some(5)).await {
        println(commit);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_3/json.rn
9c4bdaf194410d8b2f5d7f9f52eb3e64709d3414
06419f2580e7a18838f483321055fc06c0d75c4c
cba225dad143779a0a9543cfb05cde9710083af5
15133745237c014ff8bae53d8ff8f3c137c732c7
39ac97ab4ebe26118e807eb91c7656ab95b1fcac
3f6310eeeaca22d0373cc11d8b34d346bd12a364
== () (331.3324ms)
</code></pre>
<h2><a class="header" href="#using-objects-from-rust" id="using-objects-from-rust">Using objects from Rust</a></h2>
<p>Objects are represented externally as the <a href="https://docs.rs/runestick/0/runestick/type.Object.html"><code>Object</code></a> type alias. The keys are
always strings, but its value must be specified as the sole type parameter.
Note that the dynamic <a href="https://docs.rs/runestick/0/runestick/enum.Value.html"><code>Value</code></a> can be used if the type is unknown.</p>
<pre><code class="language-rust noplaypen">use rune_testing::{run, Result};
use runestick::{Object, Value};

fn main() -&gt; Result&lt;()&gt; {
    let mut object = Object::&lt;Value&gt;::new();
    object.insert(String::from(&quot;Hello&quot;), Value::from(42i64));

    let object: Object&lt;String&gt; = run(
        &amp;[&quot;calc&quot;],
        (object,),
        r#&quot;
        fn calc(input) {
            dbg(input[&quot;Hello&quot;]);
            input[&quot;Hello&quot;] = &quot;World&quot;;
            input
        }
        &quot;#,
    )?;

    println!(&quot;{:?}&quot;, object.get(&quot;Hello&quot;));
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example object
42
Some(&quot;World&quot;)
</code></pre>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>Tuples in Rune are fixed-size sequences of values. Similarly to a vector tuples
can contains any sequence of values. But there's no way to change the size of a
tuple.</p>
<pre><code class="language-rust noplaypen">fn main() {
    let values = (&quot;Now&quot;, &quot;You&quot;, &quot;See&quot;, &quot;Me&quot;);
    dbg(values)

    values.2 = &quot;Don't&quot;;
    values.3 = &quot;!&quot;;
    dbg(values)
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_4/tuple_masquerade.rn
(&quot;Now&quot;, &quot;You&quot;, &quot;See&quot;, &quot;Me&quot;)
(&quot;Now&quot;, &quot;You&quot;, &quot;Don\'t&quot;, &quot;!&quot;)
== () (38.3136ms)
</code></pre>
<p>The following is a simple example of a function returning a tuple:</p>
<pre><code class="language-rust noplaypen">fn foo() {
    (1, &quot;test&quot;)
}

fn main() {
    dbg(foo());
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_4/basic_tuples.rn
(1, &quot;test&quot;)
== () (387.6¬µs)
</code></pre>
<p>Tuples can also be pattern matched:</p>
<pre><code class="language-rust noplaypen">fn main() {
    match (&quot;test&quot;, 1) {
        (&quot;test&quot;, n) =&gt; {
            dbg(&quot;the first part was a number:&quot;, n);
        }
        _ =&gt; {
            dbg(&quot;matched something we did not understand&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_4/tuple_patterns.rn
&quot;the first part was a number:&quot;
1
== () (7.7892ms)
</code></pre>
<h2><a class="header" href="#using-tuples-from-rust" id="using-tuples-from-rust">Using tuples from Rust</a></h2>
<p>Tuples are represented externally as <a href="https://doc.rust-lang.org/std/primitive.tuple.html">primitive tuple types</a>.</p>
<pre><code class="language-rust noplaypen">use rune_testing::{run, Result};

fn main() -&gt; Result&lt;()&gt; {
    let object: (i64, i64) = run(
        &amp;[&quot;calc&quot;],
        ((1, 2),),
        r#&quot;
        fn calc(input) {
            (input.0 + 1, input.1 + 2)
        }
        &quot;#,
    )?;

    println!(&quot;{:?}&quot;, object);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example tuple
(2, 4)
</code></pre>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>Functions are truly pervasive when it comes to programming. They encapsulate a
piece of functionality and provides a contract of how they work that can be
relied on to build more complex programs.</p>
<p>In Rune, functions are declared with the <code>fn</code> keyword. You've already seen one
which is used in every example, <code>main</code>. This is not a special function, but is
simply what the Rune cli looks for when deciding what to execute.</p>
<pre><code class="language-rust noplaypen">fn main() {
    println(&quot;Hello World&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_5/main_function.rn
Hello World
== () (277.8¬µs)
</code></pre>
<p>In Rune, you don't have to specify the return type of a function. Given that
Rune is a dynamic programming language, this allows a function to return
anything. Every completely distinct types.</p>
<pre><code class="language-rust noplaypen">fn foo(condition) {
    if condition {
        &quot;Hello&quot;
    } else {
        1
    }
}

fn main() {
    println(`{foo(true)}`);
    println(`{foo(false)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_5/return_value.rn
Hello
1
== () (8.437ms)
</code></pre>
<p>Depending on who you talk to, this is either the best things since sliced bread
or quite scary. It allows for a larger ability to express a program, but at the
same time it can be harder to reason on what your program will do.</p>
<h1><a class="header" href="#structs" id="structs">Structs</a></h1>
<p>Structs are like objects, except that they have a predefined structure with a
set of keys that are known at compile time and guaranteed to be defined.</p>
<p>Structs can also, like most types, have an <code>impl</code> block associated with them
which creates instance functions that you can call on an instance of that
struct.</p>
<pre><code class="language-rust noplaypen">struct User {
    username,
    active,
}

impl User {
    fn set_active(self, active) {
        self.active = active;
    }

    fn describe(self) {
        if self.active {
            println(`{self.username} is active`);
        } else {
            println(`{self.username} is inactive`);
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.set_active(true);
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_6/user_database.rn
setbac is inactive
setbac is active
== () (6.2095ms)
</code></pre>
<p>Structs can also be pattern matched, like most types.</p>
<p>But since the fields of a struct are known at compile time, the compiler can
ensure that you're only using fields which are defined.</p>
<pre><code class="language-rust noplaypen">struct User {
    username,
    active,
}

impl User {
    fn describe(self) {
        match self {
            User { username: &quot;setbac&quot;, .. } =&gt; {
                println(&quot;Yep, it's setbac.&quot;);
            }
            User { username, .. } =&gt; {
                println(`Other user: {username}.`);
            }
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.username = &quot;newt&quot;;
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_6/struct_matching.rn
Yep, it's setbac.
Other user: newt.
== () (1.0652ms)
</code></pre>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>Rune has support for <em>enumerations</em>. These allow you to define a type with zero
or more <em>variants</em>, where each variant can hold a distinct set of data.</p>
<p>In a dynamic programming language enums might not seem quite as useful, but it's
important for Rune to support them to have a level of feature parity with Rust.</p>
<p>Even so, in this section we'll explore some cases where enums are useful.</p>
<h2><a class="header" href="#the-option-enum" id="the-option-enum">The <code>Option</code> enum</a></h2>
<p>Rune has native support for <code>Option</code>, the same enum available in Rust that
allows you to represent data that can either be present with <code>Option::Some</code>, or
absent with <code>Option::None</code>.</p>
<pre><code class="language-rust noplaypen">use std::iter::range;

fn count_numbers(limit) {
    let limit = limit.unwrap_or(10);

    for n in range(0, limit) {
        println(`Count: {n}`);
    }
}

fn main() {
    println(&quot;First count!&quot;);
    count_numbers(None);

    println(&quot;Second count!&quot;);
    count_numbers(Some(2));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/5_7/count_numbers.rn
First count!
Count: 0
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
Count: 6
Count: 7
Count: 8
Count: 9
Second count!
Count: 0
Count: 1
== () (9.0745ms)
</code></pre>
<p>Using an <code>Option</code> allows us to easily model the scenario where we have an
optional function parameter, with a default fallback value.</p>
<p>In the next section we'll be looking into a control flow construct which gives
<code>Option</code> superpowers.</p>
<p>The try operator.</p>
<h1><a class="header" href="#try-operator" id="try-operator">Try operator</a></h1>
<p>The try operator (<code>?</code>) is a control flow operator which causes a function to
return early in case the value being tried over has a certain value.</p>
<p>For <code>Option</code>, this causes the function to return if it has the <code>Option::None</code>
variant.</p>
<pre><code class="language-rust noplaypen">fn checked_div_mod(a, b) {
    let div = a.checked_div(b)?;
    Some((div, a % b))
}

fn main() {
    if let Some((div, mod)) = checked_div_mod(5, 2) {
        println(`Result: {div}, {mod}`);
    }

    if let Some((div, mod)) = checked_div_mod(5, 0) {
        println(`Result: {div}, {mod}`);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/6/basic_try.rn
Result: 2, 1
== () (7.4912ms)
</code></pre>
<h1><a class="header" href="#generators" id="generators">Generators</a></h1>
<p>Generators are a convenient method for constructing functions which are capable
of suspending themselves and their state.</p>
<p>The simplest use case for generators is to create a kind of iterator, whose
state is stored in the generator function.</p>
<p>With this, we can create a fairly efficient generator to build fibonacci
numbers.</p>
<pre><code class="language-rust noplaypen">fn fib() {
    let a = 0;
    let b = 1;

    loop {
        yield a;
        let c = a + b;
        a = b;
        b = c;
    }
}

fn main() {
    let g = fib();

    while let Some(n) = g.next() {
        dbg(n);

        if n &gt; 100 {
            break;
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/fib_generator.rn
0
1
1
2
3
5
8
13
21
34
55
89
144
== () (14.9441ms)
</code></pre>
<h2><a class="header" href="#advanced-generators-with-generatorstate" id="advanced-generators-with-generatorstate">Advanced generators with <code>GeneratorState</code></a></h2>
<p>Generators internally are a bit more complex than that.
The <code>next</code> function simply slates over some of that complexity to make simple
things easier to do.</p>
<p>The first thing to know is that <code>yield</code> itself can actually <em>produce</em> a value,
allowing the calling procedure to send values to the generator.</p>
<pre><code class="language-rust noplaypen">fn printer() {
    loop {
        let out = yield;
        dbg(out);
    }
}

fn main() {
    let printer = printer();
    printer.resume(1);
    printer.resume(&quot;John&quot;);
    printer.resume((1, 2, 3));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/send_values.rn
&quot;John&quot;
(1, 2, 3)
== () (883.2¬µs)
</code></pre>
<p>But wait, what happened to the first value we sent, <code>1</code>?</p>
<p>Well, generators don't run immediately, they need to be &quot;warmed up&quot; by calling
resume once.
At that point it runs the block prior to the first yield, we can see this by
instrumenting our code a little.</p>
<pre><code class="language-rust noplaypen">fn printer() {
    loop {
        println(&quot;waiting for value...&quot;);
        let out = yield;
        dbg(out);
    }
}

fn main() {
    let printer = printer();

    println(&quot;firing off the printer...&quot;);
    printer.resume(());
    println(&quot;ready to go!&quot;);

    printer.resume(&quot;John&quot;);
    printer.resume((1, 2, 3));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/bootup.rn
firing off the printer...
waiting for value...
ready to go!
&quot;John&quot;
waiting for value...
(1, 2, 3)
waiting for value...
== () (8.8014ms)
</code></pre>
<p>Ok, so we understand how to <em>send</em> values into a generator.
But how do we <em>receive</em> them?</p>
<p>This adds a bit of complexity, since we need to pull out <code>GeneratorState</code>.
This enum has two variants: <code>Yielded</code> and <code>Complete</code>, and represents all the
possible states a generator can suspend itself into.</p>
<pre><code class="language-rust noplaypen">fn print_once() {
    let out = yield 1;
    dbg(out);
    2
}

fn main() {
    let printer = print_once();
    dbg(printer.resume(()));
    dbg(printer.resume(&quot;John&quot;));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/states.rn
Yielded(1)
&quot;John&quot;
Complete(2)
== () (712.7¬µs)
</code></pre>
<p>After the first call to resume, we see that the generator produced <code>Yielded(1)</code>.
This corresponds to the <code>yield 1</code> statement in the generator.</p>
<p>The second value we get is <code>Complete(2)</code>.
This corresponds to the <em>return value</em> of the generator.</p>
<p>Trying to resume the generator after this will cause the virtual machine to
error.</p>
<pre><code class="language-rust noplaypen">fn print_once() {
    yield 1
}

fn main() {
    let printer = print_once();
    dbg(printer);
    dbg(printer.resume(()));
    dbg(printer.resume(&quot;John&quot;));
    dbg(printer);
    dbg(printer.resume(()));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/7/error.rn
Generator { completed: false }
Yielded(1)
Complete(&quot;John&quot;)
Generator { completed: true }
error: virtual machine error
   ‚îå‚îÄ scripts/book/7/error.rn:11:9
   ‚îÇ
11 ‚îÇ     dbg(printer.resume(()));
   ‚îÇ         ^^^^^^^^^^^^^^^^^^ cannot resume a generator that has completed
</code></pre>
<h1><a class="header" href="#asynchronous-programming" id="asynchronous-programming">Asynchronous programming</a></h1>
<p>Rune has first class support for Rust-like asynchronous programming.
In this section we'll be briefly covering what asynchronous programming is, and
how it applies to Rune as a dynamic programming language.</p>
<h2><a class="header" href="#what-is-it" id="what-is-it">What is it?</a></h2>
<p>Asynchronous code allows us to run multiple tasks concurrently, and work with
the result of those tasks.</p>
<p>A typical example would be if we want to perform multiple HTTP requests at once:</p>
<pre><code class="language-rust noplaypen">async fn main() {
    let a = http::get(&quot;https://google.com&quot;);
    let b = http::get(&quot;https://amazon.com&quot;);

    loop {
        let res = select {
            res = a =&gt; res?,
            res = b =&gt; res?,
        };

        match res {
            () =&gt; break,
            result =&gt; {
                println(`{result.status()}`);
            }
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/8/async_http.rn
200 OK
200 OK
== () (591.0319ms)
</code></pre>
<p>In the above code we send two requests <em>concurrently</em>. They are both processed
at the same time and we collect the result.</p>
<h2><a class="header" href="#select-blocks" id="select-blocks"><code>select</code> blocks</a></h2>
<p>A fundamental construct of async programming in Rune is the <code>select</code> block.
It enables us to wait on a set of futures at the same time.</p>
<p>A simple example of this is if we were to implement a simple request with a
timeout:</p>
<pre><code class="language-rust noplaypen">struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    println(`{result.status()}`);
    Ok(())
}

async fn main() {
    if let Err(Timeout) = request(1000).await {
        println(&quot;Request timed out!&quot;);
    }

    if let Err(Timeout) = request(4000).await {
        println(&quot;Request timed out!&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/8/async_http_timeout.rn
200 OK
Request timed out!
== () (3.2231404s)
</code></pre>
<p>But wait, this is taking three seconds. We're not running the requests
concurrently any longer!</p>
<p>Well, while the request and the <em>timeout</em> is run concurrently, the <code>request</code>
function is run one at-a-time.</p>
<p>To fix this we need two new things: <code>async</code> functions and <code>.await</code>.</p>
<h2><a class="header" href="#async-functions" id="async-functions"><code>async</code> functions</a></h2>
<p><code>async</code> functions are just like regular functions, except that when called they
produce a <code>Future</code>.</p>
<p>In order to get the result of this <code>Future</code> it must be <code>.await</code>ed. And <code>.await</code>
is only permitted inside of <code>async</code> functions and closures.</p>
<pre><code class="language-rust noplaypen">use std::future;

struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    Ok(result)
}

async fn main() {
    for result in future::join([request(1000), request(4000)]).await {
        match result {
            Ok(result) =&gt; println(`Result: {result.status()}`),
            Err(Timeout) =&gt; println(&quot;Request timed out!&quot;),
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/8/async_http_concurrent.rn
Result: 200 OK
Request timed out!
== () (2.0028603s)
</code></pre>
<h1><a class="header" href="#functions-and-closures" id="functions-and-closures">Functions and closures</a></h1>
<p>We've gone over functions before, and while incredibly useful there's a few more
tricks worth mentioning.</p>
<p>We'll also be talking about closures, an anonymous function with the ability to
<em>close over</em> its environment, allowing the function to use and manipulate things
from its environment.</p>
<h2><a class="header" href="#function-pointers" id="function-pointers">Function pointers</a></h2>
<p>Every function can be converted into a function pointer simply by referencing
its name without calling it.</p>
<p>This allows for some really neat tricks, like passing in a function which
represents the operation you want another function to use.</p>
<pre><code class="language-rust noplaypen">fn do_thing(op) {
    op(1, 2)
}

fn add(a, b) {
    a + b
}

fn sub(a, b) {
    a - b
}

fn main() {
    println(`{do_thing(add)}`);
    println(`{do_thing(sub)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/9/function_pointers.rn
Result: 3
Result: -1
== () (5.4354ms)
</code></pre>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<p>Closures are anonymous functions which closes over their environment.
This means that they capture any variables used inside of the closure, allowing
them to be used when the function is being called.</p>
<pre><code class="language-rust noplaypen">fn work(op) {
    op(1, 2)
}

fn main() {
    let n = 1;
    println(`Result: {work(|a, b| n + a + b)}`);
    println(`Result: {work(|a, b| n + a * b)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/9/basic_closure.rn
Result: 4
Result: 3
== () (5.4354ms)
</code></pre>
<blockquote>
<p>Hint: Closures which do not capture their environment are <em>identical</em> in
representation to a function.</p>
</blockquote>
<h1><a class="header" href="#functions-outside-of-the-vm" id="functions-outside-of-the-vm">Functions outside of the Vm</a></h1>
<p>Now things get <em>really</em> interesting.
Runestick, the virtual machine driving Rune, has support for passing function
pointers out of the virtual machine using the <code>FnPtr</code> type.</p>
<p>This allows you to write code that takes a function constructed in Rune, and use
it for something else.</p>
<p>Below we showcase this, with the help of the <code>rune!</code> macro from <code>rune-testing</code>.</p>
<pre><code class="language-rust noplaypen">use rune_testing::*;

fn main() -&gt; runestick::Result&lt;()&gt; {
    let fn_ptr: FnPtr = rune! {
        FnPtr =&gt; r#&quot;
        fn foo(a, b) {
            a + b
        }

        fn main() {
            foo
        }
        &quot;#
    };

    println!(&quot;{}&quot;, fn_ptr.call::&lt;(i64, i64), i64&gt;((1, 3))?);
    println!(&quot;{}&quot;, fn_ptr.call::&lt;(i64, i64), i64&gt;((2, 6))?);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example call_rune_fn
4
8
</code></pre>
<p>Note that these functions by necessity have to capture their entire context and
can take up quite a bit of space if you keep them around while cycling many
contexts or units.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
