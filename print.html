<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rune Programming Language</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="items_imports.html"><strong aria-hidden="true">4.1.</strong> Items and imports</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">4.2.</strong> Functions</a></li><li class="chapter-item expanded "><a href="control_flow.html"><strong aria-hidden="true">4.3.</strong> Control flow</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">4.4.</strong> Variables and memory</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">4.5.</strong> Loops</a></li><li class="chapter-item expanded "><a href="pattern_matching.html"><strong aria-hidden="true">4.6.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="template_strings.html"><strong aria-hidden="true">4.7.</strong> Template strings</a></li><li class="chapter-item expanded "><a href="instance_functions.html"><strong aria-hidden="true">4.8.</strong> Instance functions</a></li></ol></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">5.</strong> Built-in types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="primitives.html"><strong aria-hidden="true">5.1.</strong> Primitives and references</a></li><li class="chapter-item expanded "><a href="vectors.html"><strong aria-hidden="true">5.2.</strong> Vectors</a></li><li class="chapter-item expanded "><a href="objects.html"><strong aria-hidden="true">5.3.</strong> Objects</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">5.4.</strong> Tuples</a></li></ol></li><li class="chapter-item expanded "><a href="dynamic_types.html"><strong aria-hidden="true">6.</strong> Dynamic types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">6.1.</strong> Structs</a></li><li class="chapter-item expanded "><a href="enums.html"><strong aria-hidden="true">6.2.</strong> Enums</a></li></ol></li><li class="chapter-item expanded "><a href="try_operator.html"><strong aria-hidden="true">7.</strong> Try operator</a></li><li class="chapter-item expanded "><a href="generators.html"><strong aria-hidden="true">8.</strong> Generators</a></li><li class="chapter-item expanded "><a href="closures.html"><strong aria-hidden="true">9.</strong> Closures</a></li><li class="chapter-item expanded "><a href="async.html"><strong aria-hidden="true">10.</strong> Asynchronous programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="streams.html"><strong aria-hidden="true">10.1.</strong> Streams</a></li></ol></li><li class="chapter-item expanded "><a href="macros.html"><strong aria-hidden="true">11.</strong> Macros</a></li><li class="chapter-item expanded "><a href="advanced.html"><strong aria-hidden="true">12.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safety.html"><strong aria-hidden="true">12.1.</strong> Safety</a></li><li class="chapter-item expanded "><a href="the_stack.html"><strong aria-hidden="true">12.2.</strong> The stack</a></li><li class="chapter-item expanded "><a href="call_frames.html"><strong aria-hidden="true">12.3.</strong> Call frames</a></li><li class="chapter-item expanded "><a href="compiler_guide.html"><strong aria-hidden="true">12.4.</strong> Compiler guide</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Rune Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<blockquote>
<p>&quot;Why am I making a programming language?&quot;</p>
</blockquote>
<p>This question keeps rolling around in my head as I'm typing out the code that is
slowly shaping into <em>Rune</em>. Programming is like magic. You imagine it in your
mind, write it out, and there it is. Doing <em>stuff</em> which wasn't being done
before.</p>
<p>Truth be told, I'm scared that people will tell me that I'm wasting my time.
This has already been done, or &quot;Why not just use X?&quot;. A thing so glaringly
obvious that all of my efforts are wasted.</p>
<p>But you actually don't need a reason. It can simply be for The <a href="https://en.wikipedia.org/wiki/The_Joy_of_Painting">Joy of
Creating</a>, and then it's just you. Spending your own time. No harm done.</p>
<p>But I want to talk about why I'm making Rune beyond just for fun. So I'm
dedicating this foreword to it. I feel obligated to describe why this might
matter to others.</p>
<p>So here's why I'm making a new programming language.</p>
<p>I've spent a lot of effort working on <a href="https://github.com/udoprog/OxidizeBot">OxidizeBot</a>, a Twitch bot that streamers
can use to add commands and other interactive things in their chat. I built it
for myself while streaming. When adding features I always spend way too much time
tinkering with it. Making it as generic as possible so it can solve more than
just one problem. When it's a personal project, I don't care about being
efficient. I care much more about doing things the right way.</p>
<p>...</p>
<p>Ok, I <em>sometimes</em> do that professionally as well. But a working environment is
much more constrained. Personal projects should be fun!</p>
<p>Anyway, that means the bot isn't overly specialized to only suit my needs and
can be used by others. It's starting to see a little bit of that use now which
is a lot of fun. I made something which helps people do something cool.</p>
<p>All the commands in the bot are written in <a href="https://rust-lang.org">Rust</a>, and <a href="https://github.com/udoprog/OxidizeBot/tree/master/bot/src/module">compiled straight into
the bot</a>. This is nice because Rust is an incredible language. But Rust is also
complex. Not needlessly mind you. I believe it's complex because it
tackles <em>really hard problems</em>. And that usually comes with a <a href="https://en.wikipedia.org/wiki/Waterbed_theory">base level of
complexity</a> it's very hard to get rid of.</p>
<p>But it's still tricky enough that streamers who have limited programming
experience struggle getting up and running. I wanted them to be able to write
their own commands. Ones they could just drop into a folder and <em>presto</em> -
you're up and running.</p>
<blockquote>
<p>To this day I've tutored two of these streamers who were interested in
learning Rust to write their own commands.</p>
</blockquote>
<p>Embedding a Rust compiler isn't feasible. So I started looking into dynamic
programming languages. Ones that could be embedded into an existing application
with little to no effort. That seamlessly integrates with its environment.
A number of candidates came up, but the one that stood out the most to me was
<a href="https://github.com/jonathandturner/rhai">Rhai</a>.</p>
<p>So why is Rhai awesome? It has Rust-like syntax. The runtime is fully written in
mostly safe Rust, and can be easily embedded. Hooking up Rust functions is a
piece of cake.</p>
<p>But Rhai has a set of design decisions which didn't <em>exactly</em> scratch my itch.
The more I used it, the more I got inspired and started thinking about things
that could be changed or added. <a href="https://github.com/jonathandturner/rhai/commits?author=udoprog">I contributed a bit to the project</a>. And it
started to dawn on me that Rhai's approach wasn't exactly what I wanted. There's
nothing wrong with this. The authors of Rhai have specific goals and ideas of
what they want to accomplish. While it would be feasible to push Rhai in a
different direction, the project would emerge looking much different on the
other side. Which wouldn't be fair towards the people leveraging Rhai's
strengths today. So I wanted a clean slate to find my own compromises. To
discover freely what works and doesn't work well.</p>
<p>When I started working on Rune I had the following <em>rough</em> goals in mind:</p>
<ul>
<li>Performance should be comparable to Lua and Python (And eventually LuaJIT when
we have cranelift).</li>
<li>Scripts should compile quickly.</li>
<li>Rune should feel like &quot;Rust without types&quot;.</li>
<li>Excellent support for asynchronous programming (i.e. native <code>select</code> statements).</li>
<li>Be as good as Rhai when it comes to integrating with native Rust.</li>
<li>Work well through C bindings.</li>
<li>A minimalistic stack-based runtime that is strictly single threaded*.</li>
</ul>
<blockquote>
<p>*: If this feels like a step backwards to you, don't worry too much. We can
still have concurrency and threading using async code as you'll see later in
this book.</p>
</blockquote>
<p>Rune is now in a state where I want people to poke at it. Not <em>too</em> hard mind
you. It's still early days. The compiler is very much in flux and a
miscompilation will definitely cause the wrong closure to be called. You know,
the one that <em>doesn't</em> doesn't perform your security checks üòÖ.</p>
<p>But the more poking and prodding people do, the more issues will be found. Every
solved issue brings Rune one step close to being production ready. Every set of
eyeballs that takes a look can bring fresh perspective and ideas, making the
project better for me and everyone else.</p>
<p>I really want to thank Jonathan Turner and all the contributors to the Rhai
project. They have been an an immense inspiration to me. If you need an embedded
scripting engine that is more mature right now than <em>Rune</em>, please do take
<em>Rhai</em> for a spin.</p>
<p>You can find the project <a href="https://github.com/rune-rs/rune/">on its GitHub page</a>. I hope you'll enjoy using
it as much as I've enjoyed making it!</p>
<p>‚Äî John-John Tedro</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Welcome the <em>The Rune Programming Language</em>, a reference guide that will
familiarize yourself with Rune.</p>
<p>Rune is an open source embeddable dynamic programming language that compiles and
runs on a virtual machine called Runestick (thanks Brendan).</p>
<p>The goal of Rune is to reimagine Rust as a dynamic programming language. Trying
to mimic as many concepts as possible, and remixing the ones which do not
translate directly. We do this by using the same syntax as Rust. But a few
additions are inevitable because certain things are just done differently when
you have a dynamic environment.</p>
<p>I also concede that a number of program correctness features you get through
static typing will be sorely lacking. The tradeoff you get for this are fast
compilation times and <em>duck typing</em>, sometimes leading to more concise and
compact code. <a href="https://python.org">Python</a> is a great example of this, and is along with <a href="https://github.com/jonathandturner/rhai">Rhai</a> and
<a href="http://www.lua.org/">Lua</a> biggest inspirations for this project.</p>
<p>To read this book, you will definitely want to go to <a href="https://github.com/rune-rs/rune/">the GitHub project</a> and
grab yourself a clone of it. All the examples are in there, and it's highly
recommended that you run and tinker them yourself as you encounter them.</p>
<p>With that out of the way, let's get started. We have a bit to go through.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>The first thing you need to learn about in Rune is the <code>dbg</code> function. This is
used to &quot;debug&quot; values provided to it in order to understand them. Anything can
be provided to it, and it will do its best to describe it.</p>
<pre><code class="language-rune">fn main() {
    let a = [1, 2, 3];
    let b = '‰ªä';
    let closure = || println(&quot;Hello&quot;);

    dbg(a);
    dbg(b);
    dbg(function);
    dbg(drop);
    dbg(closure);
}

fn function() {
    42
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/getting_started/dbg.rn
[1, 2, 3]
'‰ªä'
dynamic function (at: 0x17)
native function (0x2959efc1c70)
Type(0x9aa62663879132fb)
== () (8.3679ms)
</code></pre>
<p>The default <code>dbg</code> implementation outputs information on its arguments to stdout.
But its exact behavior can differ depending on how the environment is
configured. When Rune is embedded into a larger application it might for example
be more suitable to output to a log file.</p>
<p>Rune also provides <code>print</code> and <code>println</code> functions which can be used to write
directly to stdout, but these cannot be relied on to be present to the same
degree as <code>dbg</code>. But for our purposes we will be using <code>rune-cli</code>, which has all
of these modules installed. This is also what was used to run the above code.</p>
<p>So for a more formal introduction, here is the official Rune <code>&quot;Hello World&quot;</code>:</p>
<pre><code class="language-rune">fn main() {
    println(&quot;Hello World&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/getting_started/hello_world.rn
Hello World
== () (1.0864ms)
</code></pre>
<blockquote>
<p>Note: Something which might trip up Rust users is that the <code>println</code> is not a
macro-like function as <code>println!</code>.</p>
</blockquote>
<p>At the end of the script's output, you see this rather odd looking line:</p>
<pre><code class="language-text">== () (1.0864ms)
</code></pre>
<p>This simply means that the script evaluated to a unit, or a <code>()</code>.
And that the execution took <code>1.0864</code> milliseconds.</p>
<blockquote>
<p>Cool Hint:
Any function that doesn't have a return value returns a unit.</p>
</blockquote>
<p>So now you know how to run Rune scripts. Well done! Let's move on to the next
chapter.</p>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<p>This chapter covers common concepts that appear in almost all programming
languages, and how they work in Rune.</p>
<p>Hopefully these should be familiar to anyone who's used imperative programming
languages before. We'll try to take each concept and describe how they work with
examples, one at a time.</p>
<h1><a class="header" href="#items-and-imports" id="items-and-imports">Items and imports</a></h1>
<p>Everything in Rune has a unique name. Every function and type. This name is what
identifies that thing, and is called its <em>item</em>. Rune performs compile time
checks to make sure that every item we try to use actually exists.</p>
<p>The following are examples of items in Rune:</p>
<ul>
<li><code>std::result::Result</code></li>
<li><code>std::test::assert</code></li>
</ul>
<p>The first refers to the <code>Result</code> enum, and the second is the <code>assert</code> function.
They both live within their corresponding <code>std</code> module. <code>Result</code> is a bit
special even, since it's part of the <em>prelude</em>, allowing us to use it without
importing it. But what about <code>assert</code>?</p>
<p>If we wanted to use <code>assert</code> we would have to import it first with a <code>use</code>
statement:</p>
<pre><code class="language-rune">use std::test::assert;

fn main() {
    assert(1 &lt; 2, &quot;one is less than two&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/items_imports/example_import.rn
== () (34.6¬µs)
</code></pre>
<p>Trying to use an item which doesn't exist results in a compile error:</p>
<pre><code class="language-rune">fn main() {
    let foo = Foo::new();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/items_imports/missing_item.rn
error: compile error
  ‚îå‚îÄ scripts/book/items_imports/missing_item.rn:2:15
  ‚îÇ
2 ‚îÇ     let foo = Foo::new();
  ‚îÇ               ^^^^^^^^^^ `Foo::new` is not a function
</code></pre>
<p>Every item used in a Rune program must be known at compile time. This is one of
the guarantees a Rune scripts are required to fulfill.</p>
<h1><a class="header" href="#dynamic-modules" id="dynamic-modules">Dynamic modules</a></h1>
<p>Rune has support for dynamic modules, purely defined in Rune itself. This is
done using the <code>mod</code> keyword. And the module can either be loaded from a
different file matching the name of the module or defined directly inside of the
source file.</p>
<p>The following is an example of an <em>inline</em> module:</p>
<pre><code class="language-rune">mod foo {
    fn get_number() {
        1
    }
}

mod bar {
    fn get_number() {
        2
    }
}

fn main() {
    foo::get_number() + bar::get_number()
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/items_imports/inline_modules.rn
== 3 (33.2¬µs)
</code></pre>
<p>And this is the equivalent modules loaded from the filesystem. These are three
separate files:</p>
<pre><code class="language-rune">mod foo;
mod bar;

fn main() {
    foo::get_number() + bar::get_number()
}
</code></pre>
<pre><code class="language-rune">// file: ./foo/mod.rn
fn get_number() {
    2
}
</code></pre>
<pre><code class="language-rune">// file: ./bar.rn
fn get_number() {
    1
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/items_imports/modules.rn
== 3 (37.5¬µs)
</code></pre>
<blockquote>
<p>Note: Rust has visibility rules (<code>pub</code>, <code>pub(crate)</code>, ...) which are not yet
implemented in Rune. See <a href="https://github.com/rune-rs/rune/issues/5">issue #5</a>.</p>
</blockquote>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>One of the most common things in all of programming are functions. These are
stored procedures which take a arguments, do some work, and then return.
Functions are used because they encapsulate what they do so that the programmer
only needs to concern itself with the protocol of the function.</p>
<p>What does it do? What kind of arguments does it take? The alternative would be
to copy the code around and that wouldn't be very modular. Functions instead
provide a modular piece of code that can be called and re-used. Over and over
again.</p>
<h2><a class="header" href="#fn-keyword" id="fn-keyword"><code>fn</code> keyword</a></h2>
<p>In Rune, functions are declared with the <code>fn</code> keyword. You've already seen one
which is used in every example, <code>main</code>. This is not a special function, but is
simply what the Rune cli looks for when deciding what to execute.</p>
<pre><code class="language-rune">fn main() {
    println(&quot;Hello World&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/functions/main_function.rn
Hello World
== () (277.8¬µs)
</code></pre>
<p>In Rune, you don't have to specify the return type of a function. Given that
Rune is a dynamic programming language, this allows a function to return
anything, even completely distinct types.</p>
<pre><code class="language-rune">fn foo(condition) {
    if condition {
        &quot;Hello&quot;
    } else {
        1
    }
}

fn main() {
    println(`{foo(true)}`);
    println(`{foo(false)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/functions/return_value.rn
Hello
1
== () (8.437ms)
</code></pre>
<p>Depending on who you talk to, this is either the best thing since sliced bread
or quite scary. It allows for a larger ability to express a program, but at the
same time it can be harder to reason on what your program will do.</p>
<h2><a class="header" href="#calling-functions-in-rust" id="calling-functions-in-rust">Calling functions in Rust</a></h2>
<p>Rune functions can be easily set up and called from Rust.</p>
<pre><code class="language-rust noplaypen">use rune::{Options, Sources, Warnings};
use runestick::{Context, FromValue, Source, Vm};
use std::sync::Arc;

fn main() -&gt; runestick::Result&lt;()&gt; {
    let context = Context::with_default_modules()?;
    let mut sources = Sources::new();

    sources.insert_default(Source::new(
        &quot;test&quot;,
        r#&quot;
         fn main(number) {
             number + 10
         }
         &quot;#,
    ));

    let unit = rune::load_sources(
        &amp;context,
        &amp;Options::default(),
        &amp;mut sources,
        &amp;mut Warnings::disabled(),
    )?;

    let vm = Vm::new(Arc::new(context), Arc::new(unit));
    let output = vm.call(&amp;[&quot;main&quot;], (33i64,))?.complete()?;
    let output = i64::from_value(output)?;

    println!(&quot;output: {}&quot;, output);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example basic_add
output: 43
</code></pre>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<p>Rune supports a number of control flow expressions. We will be dedicating this
section to describe the most common ones.</p>
<h2><a class="header" href="#return-expression" id="return-expression"><code>return</code> expression</a></h2>
<p>In the previous section we talked about functions. And one of the primary things
a function does is return things. The <code>return</code> expression allows for returning
from the current function. If used without an argument, the function will return
a unit <code>()</code>.</p>
<p>The last statement in a function is known as an <em>implicit return</em>, and will be
what the function returns by default unless a <code>return</code> is specified.</p>
<pre><code class="language-rune">fn foo(n) {
    if n &lt; 1 {
        return &quot;less than one&quot;;
    }

    &quot;something else&quot;
}

fn main() {
    println(foo(0)); // =&gt; outputs: &quot;less than one&quot;
    println(foo(10)); // =&gt; outputs: &quot;something else&quot;
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/control_flow/numbers_game.rn
less than one
something else
== () (3.8608ms)
</code></pre>
<h2><a class="header" href="#if-expressions" id="if-expressions"><code>if</code> expressions</a></h2>
<p>If expressions allow you to provide a condition with one or more code branches.
If the condition is <code>true</code>, the provided block of code will run.</p>
<pre><code class="language-rune">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;The number *is* smaller than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/control_flow/conditional.rn
The number *is* smaller than 5
== () (5.108ms)
</code></pre>
<p>Optionally, we can add another branch under <code>else</code>, which will execute in case
the condition is false.</p>
<pre><code class="language-rune">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else {
        println(&quot;the number is 5 or bigger&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/control_flow/conditional_else.rn
the number is smaller than 5
== () (196.1¬µs)
</code></pre>
<p>We can also add an arbitrary number of <code>else if</code> branches, which allow us to
specify many different conditions.</p>
<pre><code class="language-rune">fn main() {
    let number = 3;

    if number &lt; 5 {
        println(&quot;the number is smaller than 5&quot;);
    } else if number == 5 {
        println(&quot;the number is exactly 5&quot;);
    } else {
        println(&quot;the number is bigger than 5&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/control_flow/conditional_else_ifs.rn
the number is smaller than 5
== () (227.9¬µs)
</code></pre>
<p>Do note however that if you have <em>many</em> conditions, it might be cleaner to use
a <code>match</code>.</p>
<p>This will be covered in a later section, but here is a sneak peek:</p>
<pre><code class="language-rune">fn main() {
    let number = 3;

    match number {
        n if n &lt; 5 =&gt; {
            println(&quot;the number is smaller than 5&quot;);
        }
        5 =&gt; {
            println(&quot;the number is exactly 5&quot;);
        }
        n =&gt; {
            println(&quot;the number is bigger than 5&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/control_flow/first_match.rn
the number is smaller than 5
== () (124.2¬µs)
</code></pre>
<h1><a class="header" href="#variables-and-memory" id="variables-and-memory">Variables and memory</a></h1>
<p>Variables in Rune are defined using the <code>let</code> keyword. In contrast to Rust, all
variables in Rune are mutable and can be changed at any time.</p>
<pre><code class="language-rune">fn main() {
    let x = 5;
    println(`The value of x is: {x}`);
    x = 6;
    println(`The value of x is: {x}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/variables/variables.rn
The value of x is: 5
The value of x is: 6
</code></pre>
<p>Rune is a memory safe language. Regardless of what you write in a Rune script,
we maintain the same memory safety guarantees as safe Rust. This is accomplished
through reference counting.</p>
<p><a href="5_1_primitives.html">Unless a value is <code>Copy</code></a>, they are reference counted and
can be used at multiple locations. This means that they have <em>shared ownership</em>.
Every variable that points to that value therefore points to <em>the same instance</em>
of that value. You can think of every nontrivial value being automatically
wrapped in an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> if that helps you out.</p>
<blockquote>
<p>This is not exactly what's going on. If you're interested to learn more, Rune
uses a container called <a href="https://docs.rs/runestick/0/runestick/struct.Shared.html"><code>Shared&lt;T&gt;</code></a> which is <em>like</em> an <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>, but
has a few more tricks.</p>
</blockquote>
<p>We can see how this works by sharing and mutating one object across two
variables:</p>
<pre><code class="language-rune">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`{object.field}`);
    object2.field = 2;

    // Note: we changed `object2`, but read out `object`
    println(`{object.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/variables/shared_ownership.rn
1
2
== () (913.4¬µs)
</code></pre>
<p>This can cause issues if we call an external function which expects to take
ownership of its arguments. We say that functions like these <em>move</em> their
argument, and if we try to use a variable which has been moved an error will be
raised in the virtual machine.</p>
<blockquote>
<p>Note: Below we use the <code>drop</code> function, which is a built-in function that will
take its argument and free it.</p>
</blockquote>
<pre><code class="language-rune">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);
    println(`field: {object.field}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/variables/take_argument.rn
field: 1
error: virtual machine error
  ‚îå‚îÄ scripts/book/variables/take_argument.rn:6:22
  ‚îÇ
6 ‚îÇ     println(`field: {object.field}`);
  ‚îÇ                      ^^^^^^^^^^^^ failed to access value: cannot read, value is moved
</code></pre>
<p>If you need to, you can test if a variable is still accessible for reading with
<code>is_readable</code>, and for writing with <code>is_writable</code>. These are both imported in
the prelude. An object which is writable is also <em>movable</em>, and can be provided
to functions which need to move the value, like <code>drop</code>.</p>
<pre><code class="language-rune">fn main() {
    let object = #{field: 1};
    let object2 = object;
    println(`field: {object.field}`);
    drop(object2);

    if is_readable(object) {
        println(`field: {object.field}`);
    } else {
        println(&quot;object is no longer readable üò¢&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/variables/is_readable.rn
field: 1
object is no longer readable üò¢
== () (943.8¬µs)
</code></pre>
<h1><a class="header" href="#loops" id="loops">Loops</a></h1>
<p>Loops are a fundamental building block common to many programming languages.
This is no exception in Rune.
Loops allow you to execute a block of code until a specific condition is
reached, which can be a powerful tool for accomplishing programming tasks.</p>
<h2><a class="header" href="#break-keyword" id="break-keyword"><code>break</code> Keyword</a></h2>
<p>Every loop documented in this section can be <em>terminated early</em> using the
<code>break</code> keyword.</p>
<p>When Rune encounters a break, it will immediately jump out of the loop it is
currently in and continue running right after it.</p>
<pre><code class="language-rune">fn main() {
    let value = 0;

    while value &lt; 100 {
        if value &gt;= 50 {
            break;
        }

        value = value + 1;
    }

    println(`The value is {value}`); // =&gt; The value is 50
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/loops/while_loop.rn
The value is 50
== () (501.1¬µs)
</code></pre>
<h2><a class="header" href="#loop-expressions" id="loop-expressions"><code>loop</code> Expressions</a></h2>
<p>The <code>loop</code> keyword builds the most fundamental form of loop in Rune.
One that repeats unconditionally forever, until it is exited using another
control flow operator like a <code>break</code> or a <code>return</code>.</p>
<pre><code class="language-rune">use time::Duration;

async fn main() {
    loop {
        println(&quot;Hello forever!&quot;);
        time::delay_for(Duration::from_secs(1)).await;
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/loops/loop_forever.rn
Hello forever!
Hello forever!
Hello forever!
...
</code></pre>
<blockquote>
<p>Hint: If you want this one to end, you're gonna have to kill it with <code>CTRL+C</code>.</p>
</blockquote>
<p>We're also using an asynchronous function called <code>delay_for</code> above to avoid
spamming our terminals too much.
Well talk more about these in a later section.</p>
<p>When broken out of, loops produce the value provided as an argument to the
<code>break</code> keyword.
By default, this is simply a unit <code>()</code>.</p>
<pre><code class="language-rune">fn main() {
    let counter = 0;

    let total = loop {
        counter = counter + 1;

        if counter &gt; 10 {
            break counter;
        }
    };

    println(`The final count is: {total}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/loops/loop_break.rn
The final count is: 11
== () (281.5¬µs)
</code></pre>
<h1><a class="header" href="#pattern-matching" id="pattern-matching">Pattern Matching</a></h1>
<p>In this section we will be discussing <em>Pattern Matching</em>.</p>
<p>Pattern matching is a flexible mechanism that allows for validating the
structure and type of the argument, while also destructuring it to give easy
access to what you need.</p>
<p>Below are some examples of its common uses to match on branch conditions:</p>
<pre><code class="language-rune">fn match_input(n) {
    match n {
        1 =&gt; println(&quot;The number one.&quot;),
        n if n is int =&gt; println(`Another number: {n}.`),
        [1, 2, n, ..] =&gt; println(`A vector starting with one and two, followed by {n}.`),
        &quot;one&quot; =&gt; println(&quot;One, but this time as a string.&quot;),
        _ =&gt; println(&quot;Something else. Can I go eat now?&quot;),
    }
}

fn main() {
    match_input(1);
    match_input(2);
    match_input([1, 2, 42, 84]);
    match_input(&quot;one&quot;);
    match_input(#{field: 42});
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/pattern_matching/big_match.rn
The number one.
Another number: 2.
A vector starting with one and two, followed by 42.
One, but this time as a string.
Something else. Can I go eat now?
== () (5.691ms)
</code></pre>
<p>We will be covering each of these variants in detail in the coming sections.</p>
<h2><a class="header" href="#matching-literals" id="matching-literals">Matching Literals</a></h2>
<p>Literals are the simplest form of matching, where we test if the branch is
exactly equal to a literal.</p>
<p>Literals take a number of form:</p>
<ul>
<li>A literal unit, simply <code>()</code>.</li>
<li>A literal boolean, like <code>true</code> or <code>false</code>.</li>
<li>A literal character, like <code>'a'</code> or <code>'„ÅÇ'</code>.</li>
<li>A literal integer, like <code>42</code>.</li>
<li>A string, like <code>&quot;Steven Universe&quot;</code>.</li>
<li>A vector, like the numbers <code>[4, 8, 15, 16, 23, 42]</code> or the empty vector <code>[]</code>.</li>
<li>A tuple, like <code>(&quot;Steven Universe&quot;, 42)</code>.</li>
<li>An object, like the numbers <code>{&quot;name&quot;: &quot;Steven Universe&quot;}</code> or the empty <code>{}</code>.</li>
</ul>
<p>Finally, literals can be <em>any</em> combination of the above.
Even <code>{&quot;items&quot;: [&quot;Sword&quot;, &quot;Bow&quot;, &quot;Axe&quot;]}</code> is a literal that can be matched over.</p>
<h2><a class="header" href="#match-bindings" id="match-bindings">Match Bindings</a></h2>
<p>In a pattern, every literal value can also be replaced with an ignore directive
or a binding.</p>
<p>The ignore directive looks like an underscore <code>_</code>, which tells rune to <em>ignore</em>
the value, allowing it to have any value.</p>
<pre><code class="language-rune">fn test_ignore(vector) {
    match vector {
        [_, 2] =&gt; println(&quot;Second item in vector is 2.&quot;),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/pattern_matching/ignore.rn
Second item in vector is 2.
== () (281.3¬µs)
</code></pre>
<p>In contrast to ignoring, we can also <em>bind</em> the value to a variable that is then
in scope of the match arm.</p>
<pre><code class="language-rune">fn test_ignore(vector) {
    match vector {
        [_, b] =&gt; println(`Second item in vector is {b}.`),
    }
}

fn main() {
    test_ignore([1, 2]);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/pattern_matching/bind.rn
Second item in vector is 2.
== () (6.25ms)
</code></pre>
<p>Here are some more examples:</p>
<ul>
<li><code>[_, a, b]</code> which will ignore the first, but then capture the second and third
element in the vector.</li>
<li><code>{&quot;name&quot;: name}</code> will capture the <code>name</code> value out of the specified object.</li>
</ul>
<p>Finally we can also add the sequence <code>..</code> to ask Rune to <em>ignore</em> any additional
values in a collection that might be present when matching a vector or an
object.</p>
<pre><code class="language-rune">fn describe_car(car) {
    match car {
        #{&quot;make&quot;: year, ..} if year &lt; 1950 =&gt; &quot;What, where did you get that?&quot;,
        #{&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: year, ..} if year &gt;= 2000 =&gt; &quot;Pretty fast!&quot;,
        _ =&gt; &quot;Can't tell üòû&quot;,
    }
}

fn main() {
    println(describe_car(#{&quot;model&quot;: &quot;Ford&quot;, &quot;make&quot;: 2000}));
    println(describe_car(#{&quot;model&quot;: &quot;Honda&quot;, &quot;make&quot;: 1980}));
    println(describe_car(#{&quot;model&quot;: &quot;Volvo&quot;, &quot;make&quot;: 1910}));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/pattern_matching/fast_cars.rn
Pretty fast!
Can't tell üòû
What, where did you get that?
== () (5.3533ms)
</code></pre>
<h1><a class="header" href="#template-strings" id="template-strings">Template strings</a></h1>
<p>If you've been paying attention on previous sections you might have seen odd
looking strings like <code>`Hello {name}`</code>. These are called <em>template strings</em>,
and allow you to conveniently build strings using variables from the
environment.</p>
<pre><code class="language-rune">fn main() {
    let age = 30;
    println(`I am {age} years old!`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/template_strings/basic_template.rn
I am 30 years old!
== () (4.5678ms)
</code></pre>
<p>Template strings are accelerated by the Vm, each argument uses a <em>display
protocol</em> and it can be very efficient to build complex strings out of it.</p>
<h2><a class="header" href="#the-string_display-protocol" id="the-string_display-protocol">The <code>STRING_DISPLAY</code> protocol</a></h2>
<p>The <code>STRING_DISPLAY</code> protocol is a function that can be implemented by any
<em>external</em> type which allows it to be used in a template string.</p>
<p>It expects a function with the signature <code>fn(&amp;self, buf: &amp;mut String) -&gt; fmt::Result</code>.</p>
<pre><code class="language-rust noplaypen">use std::fmt::Write as _;
use std::fmt;

#[derive(Debug)]
pub struct StatusCode {
    inner: u32,
}

impl StatusCode {
    fn display(&amp;self, buf: &amp;mut String) -&gt; fmt::Result {
        write!(buf, &quot;{}&quot;, self.inner)
    }
}

pub fn module() -&gt; Result&lt;runestick::Module, runestick::ContextError&gt; {
    let mut module = runestick::Module::new(&amp;[&quot;http&quot;]);
    module.inst_fn(runestick::STRING_DISPLAY, StatusCode::display)?;
    Ok(module)
}
</code></pre>
<p>This is what allows status codes to be formatted into template strings, any
types which do not implement this protocol will fail to run.</p>
<pre><code class="language-rune">fn main() {
    let vec = [1, 2, 3];
    println(`{vec}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/template_strings/not_a_template.rn
error: virtual machine error
  ‚îå‚îÄ scripts/book/template_strings/not_a_template.rn:3:13
  ‚îÇ
3 ‚îÇ     println(`{vec}`);
  ‚îÇ             ^^^^^^^ `vector` does not implement the `string_display` protocol
</code></pre>
<h1><a class="header" href="#instance-functions" id="instance-functions">Instance functions</a></h1>
<p>Instance functions are functions that are associated to a specific type of
variable. When called they take the form <code>value.foo()</code>, where the <em>instance</em>
is the first part <code>value</code>. And the <em>instance function</em> is <code>foo()</code>.</p>
<p>These are a bit special in Rune. Since Rune is a dynamic programming language we
can't tell at compile time which instance any specific <code>value</code> can be. So
instance functions must be looked up at runtime.</p>
<pre><code class="language-rune">struct Foo;

impl Foo {
    fn new() {
        Foo
    }
}

fn main() {
    let foo = Foo::new();
    foo.bar();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/instance_functions/missing_instance_fn.rn
error: virtual machine error
   ‚îå‚îÄ scripts/book/instance_functions/missing_instance_fn.rn:11:5
   ‚îÇ
11 ‚îÇ     foo.bar();
   ‚îÇ     ^^^^^^^^^ missing instance function `0xfb67fa086988a22d` for `type(0xc153807c3ddc98d7)``
</code></pre>
<blockquote>
<p>Note: The error is currently a bit nondescript. But in the future we will be
able to provide better diagnostics by adding debug information.</p>
</blockquote>
<p>What you're seeing above are type and function hashes. These uniquely identify
the item in the virtual machine and is the result of a deterministic computation
based on its item. So the hash for the item <code>Foo::new</code> will always be the same.</p>
<p>In Rust, we can calculate this hash using the <code>Hash::type_hash</code> method:</p>
<pre><code class="language-rune">use runestick::{Hash, Item};

fn main() {
    println!(&quot;{}&quot;, Hash::type_hash(&amp;Item::of(&amp;[&quot;Foo&quot;, &quot;new&quot;])));
    println!(&quot;{}&quot;, Hash::type_hash(&amp;[&quot;Foo&quot;, &quot;new&quot;]));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example function_hash
0xb5dc92ab43cb37d9
0xb5dc92ab43cb37d9
</code></pre>
<p>The exact implementation of the hash function is currently not defined, but will
be stabilized and documented in a future release.</p>
<h2><a class="header" href="#defining-instance-functions-in-rust" id="defining-instance-functions-in-rust">Defining instance functions in Rust</a></h2>
<p>Native instance functions are added to a runtime environment using the
<a href="https://docs.rs/runestick/0.5.3/runestick/struct.Module.html#method.inst_fn"><code>Module::inst_fn</code></a> and <a href="https://docs.rs/runestick/0.5.3/runestick/struct.Module.html#method.async_inst_fn"><code>Module::async_inst_fn</code></a> functions. The type is
identified as the first argument of the instance function, and must be a type
registered in the module using <a href="https://docs.rs/runestick/0.5.3/runestick/struct.Module.html#method.ty"><code>Module::ty</code></a>.</p>
<pre><code class="language-rust noplaypen">use rune::{Options, Sources, Warnings};
use runestick::{Context, FromValue, Module, Source, Vm};
use std::sync::Arc;

fn divide_by_three(value: i64) -&gt; i64 {
    value / 3
}

#[tokio::main]
async fn main() -&gt; runestick::Result&lt;()&gt; {
    let mut my_module = Module::new(&amp;[&quot;mymodule&quot;]);
    my_module.inst_fn(&quot;divide_by_three&quot;, divide_by_three)?;

    let mut context = Context::with_default_modules()?;
    context.install(&amp;my_module)?;

    let options = Options::default();
    let mut warnings = Warnings::disabled();
    let mut sources = Sources::new();

    sources.insert_default(Source::new(
        &quot;test&quot;,
        r#&quot;
        fn main(number) {
            number.divide_by_three()
        }
        &quot;#,
    ));

    let unit = rune::load_sources(&amp;context, &amp;options, &amp;mut sources, &amp;mut warnings)?;

    let vm = Vm::new(Arc::new(context), Arc::new(unit));
    let output = vm.call(&amp;[&quot;main&quot;], (33i64,))?.complete()?;
    let output = i64::from_value(output)?;

    println!(&quot;output: {}&quot;, output);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example custom_instance_fn
output: 11
</code></pre>
<p>For more examples on how modules can be used you can have a look at the source
for the <a href="https://github.com/rune-rs/rune/tree/master/crates/rune-modules"><code>rune-modules</code></a> crate.</p>
<h1><a class="header" href="#rune-types" id="rune-types">Rune types</a></h1>
<p>Types in Rune are identified uniquely by their <em>item</em>. An item path is a
scope-separated identifier, like <code>std::float</code>. This particular item identifies
a type.</p>
<p>These items can be used to perform basic type checking using the <code>is</code> and <code>is not</code> operations, like this:</p>
<pre><code class="language-rune">use std::test::assert;

fn main() {
    assert(() is unit, &quot;units should be units&quot;);
    assert(true is bool, &quot;bools should be bools&quot;);
    assert('a' is char, &quot;chars should be chars&quot;);
    assert(b'a' is byte, &quot;bytes should be bytes&quot;);
    assert(42 is int, &quot;integers should be integers&quot;);
    assert(42.1 is float, &quot;floats should be floats&quot;);
    assert(&quot;hello&quot; is String, &quot;strings should be strings&quot;);
    assert(&quot;x&quot; is not char, &quot;strings are not chars&quot;);
    assert(#{&quot;hello&quot;: &quot;world&quot;} is Object, &quot;objects should be objects&quot;);
    assert([&quot;hello&quot;, &quot;world&quot;] is Vec, &quot;vectors should be vectors&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/types/types.rn
== () (120¬µs)
</code></pre>
<p>Conversely, the type check would fail if you're providing a value which is not
of that type.</p>
<pre><code class="language-rune">use std::test::assert;

fn main() {
    assert([&quot;hello&quot;, &quot;world&quot;] is String, &quot;vectors should be strings&quot;);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/types/bad_type_check.rn
error: virtual machine error
  ‚îå‚îÄ scripts/book/types/bad_type_check.rn:4:5
  ‚îÇ
4 ‚îÇ     assert([&quot;hello&quot;, &quot;world&quot;] is String, &quot;vectors should be strings&quot;);
  ‚îÇ     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ panicked `assertion failed `vectors should be strings``
</code></pre>
<p>This gives us insight at runtime which type is which, and allows Rune scripts to
make decisions depending on what type a value has.</p>
<pre><code class="language-rune">fn dynamic_type(n) {
    if n is String {
        &quot;n is a String&quot;
    } else if n is Vec {
        &quot;n is a vector&quot;
    } else {
        &quot;n is unknown&quot;
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/types/type_check.rn
n is a String
n is a vector
n is unknown
== () (1.0544ms)
</code></pre>
<p>A tighter way to accomplish this would be by using pattern matching, a mechanism
especially suited for many conditional branches. Especially when the branches
are different types or variants in an enum.</p>
<pre><code class="language-rune">fn dynamic_type(n) {
    match n {
        n if n is String =&gt; &quot;n is a String&quot;,
        n if n is Vec =&gt; &quot;n is a vector&quot;,
        _ =&gt; &quot;n is unknown&quot;,
    }
}

fn main() {
    println(dynamic_type(&quot;Hello&quot;));
    println(dynamic_type([1, 2, 3, 4]));
    println(dynamic_type(42));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/types/type_check_patterns.rn
n is a String
n is a vector
n is unknown
== () (1.0341ms)
</code></pre>
<h1><a class="header" href="#primitive-and-reference-types" id="primitive-and-reference-types">Primitive and reference types</a></h1>
<p>Primitives are values stored immediately on the stack. In Rust terminology,
these types are <code>Copy</code>, so reassigning them to different values will create
distinct <em>copies</em> of the underlying value.</p>
<p>The primitives available in Rune are:</p>
<ul>
<li>the unit <code>()</code>.</li>
<li>booleans, <code>true</code> and <code>false</code>.</li>
<li>bytes, like <code>b'\xff'</code>.</li>
<li>characters, like <code>'‰ªä'</code>.</li>
<li>integers, like <code>42</code>.</li>
<li>floats, like <code>3.1418</code>.</li>
<li>static strings, like <code>&quot;Hello World&quot;</code>.</li>
<li>type hashes.</li>
</ul>
<p>You can see that these bytes are <code>Copy</code> when assigning them to a different
variable, because a separate copy of the variable will be used.</p>
<pre><code class="language-rune">fn main() {
    let a = 1;
    let b = a;
    a = 2;
    println(`{a}`);
    println(`{b}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/primitives/copy.rn
2
1
== () (691.3¬µs)
</code></pre>
<p>Other types like <em>strings</em> are stored by reference on the stack. Assigning them
to a different variable will only <em>copy their reference</em>, but they still point
to the same underlying data.</p>
<pre><code class="language-rune">fn main() {
    let a = String::from_str(&quot;Hello&quot;);
    let b = a;
    a.push_str(&quot; World&quot;);
    println(a);
    println(b);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/primitives/primitives.rn
Hello World
Hello World
== () (9.7406ms)
</code></pre>
<h1><a class="header" href="#vectors" id="vectors">Vectors</a></h1>
<p>A vector is a native data structure of Rune which is a dynamic list of values. A
vector isn't typed, and can store <em>any</em> Rune values.</p>
<pre><code class="language-rune">fn main() {
    let values = [&quot;Hello&quot;, 42];

    dbg(values[0]);
    dbg(values.1); // items be accessed like tuple fields.

    for v in values {
        dbg(v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/vectors/vectors.rn
&quot;Hello&quot;
42
&quot;Hello&quot;
42
== () (5.0674ms)
</code></pre>
<p>As you can see, you can iterate over a vector because it implements the iterator
protocol. It is also possible to create and use an iterator manually using
<code>Vec::iter</code>, giving you more control over it.</p>
<pre><code class="language-rune">fn main() {
    let values = [&quot;Hello&quot;, 42];

    for v in values.iter().rev() {
        dbg(v);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/vectors/vectors_rev.rn
42
&quot;Hello&quot;
== () (2.9116ms)
</code></pre>
<h2><a class="header" href="#using-vectors-from-rust" id="using-vectors-from-rust">Using vectors from Rust</a></h2>
<p>Vectors are represented externally as the standard <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">use rune_testing::{run, Result};

fn main() -&gt; Result&lt;()&gt; {
    let input: Vec&lt;i64&gt; = vec![1, 2, 3, 4];

    let output: Vec&lt;i64&gt; = run(
        &amp;[&quot;calc&quot;],
        (input,),
        r#&quot;
        fn calc(input) {
            let output = 0;

            for value in input {
                output += value;
            }

            [output]
        }
        &quot;#,
    )?;

    println!(&quot;{:?}&quot;, output);
    Ok(())
}
</code></pre></pre>
<pre><code class="language-text">$&gt; cargo run --example vector
[10]
</code></pre>
<p>If you have a vector which has values of non-uniform types, you can use 
<a href="https://docs.rs/runestick/0/runestick/struct.VecTuple.html"><code>VecTuple</code></a> to deal with them.</p>
<pre><pre class="playground"><code class="language-rust">use rune_testing::{run, Result};
use runestick::VecTuple;

fn main() -&gt; Result&lt;()&gt; {
    let input: VecTuple&lt;(i64, String)&gt; = VecTuple::new((1, String::from(&quot;Hello&quot;)));

    let output: VecTuple&lt;(i64, String)&gt; = run(
        &amp;[&quot;calc&quot;],
        (input,),
        r#&quot;
        fn calc(input) {
            let a = input[0] + 1;
            let b = `{input[1]} World`;
            [a, b]
        }
        &quot;#,
    )?;

    let VecTuple((a, b)) = output;
    println!(&quot;({:?}, {:?})&quot;, a, b);
    Ok(())
}
</code></pre></pre>
<pre><code class="language-text">$&gt; cargo run --example vec_tuple
(2, &quot;Hello World&quot;)
</code></pre>
<h1><a class="header" href="#objects" id="objects">Objects</a></h1>
<p>Objects are anonymous maps, which support defining and using arbitrary string
keys.</p>
<pre><code class="language-rune">use std::test::assert;

fn main() {
    let values = #{};
    values[&quot;first&quot;] = &quot;bar&quot;;
    values[&quot;second&quot;] = 42;

    dbg(values[&quot;first&quot;]);
    dbg(values.second); // items be accessed like struct fields.

    if let Some(key) = values.get(&quot;not a key&quot;) {
        dbg(key);
    } else {
        println(&quot;key did not exist&quot;);
    }

    for entry in values {
        dbg(entry);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/objects/objects.rn
&quot;bar&quot;
42
key did not exist
(&quot;second&quot;, 42)
(&quot;first&quot;, &quot;bar&quot;)
== () (3.3527ms)
</code></pre>
<p>These are useful because they allow their data to be specified dynamically,
which is exactly the same use case as storing unknown JSON.</p>
<p>One of the biggest motivations for Rune to have anonymous objects is so that
we can natively handle data with unknown structure.</p>
<pre><code class="language-rune">async fn get_commits(repo, limit) {
    let limit = limit.unwrap_or(10);

    let client = http::Client::new();
    let request = client.get(`https://api.github.com/repos/{repo}/commits`).await?;
    let response = request.header(&quot;User-Agent&quot;, &quot;Rune&quot;).send().await?;
    let text = response.text().await?;
    let json = json::from_string(text)?;

    let commits = Vec::new();
    let count = 0;

    for entry in json {
        commits.push(entry.sha);

        if count &gt;= limit {
            break;
        }

        count += 1;
    }

    commits
}

async fn main() {
    for commit in get_commits(&quot;rune-rs/rune&quot;, Some(5)).await {
        println(commit);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/objects/json.rn
9c4bdaf194410d8b2f5d7f9f52eb3e64709d3414
06419f2580e7a18838f483321055fc06c0d75c4c
cba225dad143779a0a9543cfb05cde9710083af5
15133745237c014ff8bae53d8ff8f3c137c732c7
39ac97ab4ebe26118e807eb91c7656ab95b1fcac
3f6310eeeaca22d0373cc11d8b34d346bd12a364
== () (331.3324ms)
</code></pre>
<h2><a class="header" href="#using-objects-from-rust" id="using-objects-from-rust">Using objects from Rust</a></h2>
<p>Objects are represented externally as the <a href="https://docs.rs/runestick/0/runestick/type.Object.html"><code>Object</code></a> type alias. The keys are
always strings, but its value must be specified as the sole type parameter.
Note that the dynamic <a href="https://docs.rs/runestick/0/runestick/enum.Value.html"><code>Value</code></a> can be used if the type is unknown.</p>
<pre><code class="language-rust noplaypen">use rune_testing::{run, Result};
use runestick::{Object, Value};

fn main() -&gt; Result&lt;()&gt; {
    let mut object = Object::&lt;Value&gt;::new();
    object.insert(String::from(&quot;Hello&quot;), Value::from(42i64));

    let object: Object&lt;String&gt; = run(
        &amp;[&quot;calc&quot;],
        (object,),
        r#&quot;
        fn calc(input) {
            dbg(input[&quot;Hello&quot;]);
            input[&quot;Hello&quot;] = &quot;World&quot;;
            input
        }
        &quot;#,
    )?;

    println!(&quot;{:?}&quot;, object.get(&quot;Hello&quot;));
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example object
42
Some(&quot;World&quot;)
</code></pre>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>Tuples in Rune are fixed-size sequences of values. Similarly to a vector, tuples
can contain any sequence of values. But there's no way to change the size of a
tuple.</p>
<pre><code class="language-rune">fn main() {
    let values = (&quot;Now&quot;, &quot;You&quot;, &quot;See&quot;, &quot;Me&quot;);
    dbg(values);

    values.2 = &quot;Don't&quot;;
    values.3 = &quot;!&quot;;
    dbg(values);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/tuples/tuple_masquerade.rn
(&quot;Now&quot;, &quot;You&quot;, &quot;See&quot;, &quot;Me&quot;)
(&quot;Now&quot;, &quot;You&quot;, &quot;Don\'t&quot;, &quot;!&quot;)
== () (38.3136ms)
</code></pre>
<p>The following is a simple example of a function returning a tuple:</p>
<pre><code class="language-rune">fn foo() {
    (1, &quot;test&quot;)
}

fn main() {
    dbg(foo());
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/tuples/basic_tuples.rn
(1, &quot;test&quot;)
== () (387.6¬µs)
</code></pre>
<p>Tuples can also be pattern matched:</p>
<pre><code class="language-rune">fn main() {
    match (&quot;test&quot;, 1) {
        (&quot;test&quot;, n) =&gt; {
            dbg(&quot;the first part was a number:&quot;, n);
        }
        _ =&gt; {
            dbg(&quot;matched something we did not understand&quot;);
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/tuples/tuple_patterns.rn
&quot;the first part was a number:&quot;
1
== () (7.7892ms)
</code></pre>
<h2><a class="header" href="#using-tuples-from-rust" id="using-tuples-from-rust">Using tuples from Rust</a></h2>
<p>Tuples are represented externally as <a href="https://doc.rust-lang.org/std/primitive.tuple.html">primitive tuple types</a>.</p>
<pre><code class="language-rust noplaypen">use rune_testing::{run, Result};

fn main() -&gt; Result&lt;()&gt; {
    let object: (i64, i64) = run(
        &amp;[&quot;calc&quot;],
        ((1, 2),),
        r#&quot;
        fn calc(input) {
            (input.0 + 1, input.1 + 2)
        }
        &quot;#,
    )?;

    println!(&quot;{:?}&quot;, object);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example tuple
(2, 4)
</code></pre>
<h1><a class="header" href="#dynamic-types" id="dynamic-types">Dynamic types</a></h1>
<p>Dynamic types are types which can be defined and used solely within a Rune
script. They provide the ability to structure data and associate functions with
it.</p>
<p>The following is a quick example of a <code>struct</code>:</p>
<pre><code class="language-rune">struct Person {
    name,
}

impl Person {
    fn greet(self) {
        println(`Greetings from {self.name}, and good luck with this section!`);
    }
}

fn main() {
    let person = Person {
        name: &quot;John-John Tedro&quot;,
    };

    person.greet();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/dynamic_types/greeting.rn
Greetings from John-John Tedro, and good luck with this section!
== () (2.7585ms)
</code></pre>
<h1><a class="header" href="#structs" id="structs">Structs</a></h1>
<p>Structs are like objects, except that they have a predefined structure with a
set of keys that are known at compile time and guaranteed to be defined.</p>
<p>Structs can also, like most types, have an <code>impl</code> block associated with them
which creates instance functions that you can call on an instance of that
struct.</p>
<pre><code class="language-rune">struct User {
    username,
    active,
}

impl User {
    fn set_active(self, active) {
        self.active = active;
    }

    fn describe(self) {
        if self.active {
            println(`{self.username} is active`);
        } else {
            println(`{self.username} is inactive`);
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.set_active(true);
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/structs/user_database.rn
setbac is inactive
setbac is active
== () (6.2095ms)
</code></pre>
<p>Structs can also be pattern matched, like most types.</p>
<p>But since the fields of a struct are known at compile time, the compiler can
ensure that you're only using fields which are defined.</p>
<pre><code class="language-rune">struct User {
    username,
    active,
}

impl User {
    fn describe(self) {
        match self {
            User { username: &quot;setbac&quot;, .. } =&gt; {
                println(&quot;Yep, it's setbac.&quot;);
            }
            User { username, .. } =&gt; {
                println(`Other user: {username}.`);
            }
        }
    }
}

fn main() {
    let user = User {
        username: &quot;setbac&quot;,
        active: false,
    };

    user.describe();
    user.username = &quot;newt&quot;;
    user.describe();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/structs/struct_matching.rn
Yep, it's setbac.
Other user: newt.
== () (1.0652ms)
</code></pre>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>Rune has support for <em>enumerations</em>. These allow you to define a type with zero
or more <em>variants</em>, where each variant can hold a distinct set of data.</p>
<p>In a dynamic programming language enums might not seem quite as useful, but it's
important for Rune to support them to have a level of feature parity with Rust.</p>
<p>Even so, in this section we'll explore some cases where enums are useful.</p>
<h2><a class="header" href="#the-option-enum" id="the-option-enum">The <code>Option</code> enum</a></h2>
<p>Rune has native support for <code>Option</code>, the same enum available in Rust that
allows you to represent data that can either be present with <code>Option::Some</code>, or
absent with <code>Option::None</code>.</p>
<pre><code class="language-rune">use std::iter::range;

fn count_numbers(limit) {
    let limit = limit.unwrap_or(10);

    for n in range(0, limit) {
        println(`Count: {n}`);
    }
}

fn main() {
    println(&quot;First count!&quot;);
    count_numbers(None);

    println(&quot;Second count!&quot;);
    count_numbers(Some(2));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/enums/count_numbers.rn
First count!
Count: 0
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5
Count: 6
Count: 7
Count: 8
Count: 9
Second count!
Count: 0
Count: 1
== () (9.0745ms)
</code></pre>
<p>Using an <code>Option</code> allows us to easily model the scenario where we have an
optional function parameter, with a default fallback value.</p>
<p>In the next section we'll be looking into a control flow construct which gives
<code>Option</code> superpowers.</p>
<p>The try operator.</p>
<h1><a class="header" href="#try-operator" id="try-operator">Try operator</a></h1>
<p>The try operator (<code>?</code>) is a control flow operator which causes a function to
return early in case the value being tried over has a certain value.</p>
<p>For <code>Option</code>, this causes the function to return if it has the <code>Option::None</code>
variant.</p>
<pre><code class="language-rune">fn checked_div_mod(a, b) {
    let div = a.checked_div(b)?;
    Some((div, a % b))
}

fn main() {
    if let Some((div, mod)) = checked_div_mod(5, 2) {
        println(`Result: {div}, {mod}`);
    }

    if let Some((div, mod)) = checked_div_mod(5, 0) {
        println(`Result: {div}, {mod}`);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/try_operator/basic_try.rn
Result: 2, 1
== () (7.4912ms)
</code></pre>
<h1><a class="header" href="#generators" id="generators">Generators</a></h1>
<p>Generators are a convenient method for constructing functions which are capable
of suspending themselves and their state.</p>
<p>The simplest use case for generators is to create a kind of iterator, whose
state is stored in the generator function.</p>
<p>With this, we can create a fairly efficient generator to build fibonacci
numbers.</p>
<pre><code class="language-rune">fn fib() {
    let a = 0;
    let b = 1;

    loop {
        yield a;
        let c = a + b;
        a = b;
        b = c;
    }
}

fn main() {
    let g = fib();

    while let Some(n) = g.next() {
        dbg(n);

        if n &gt; 100 {
            break;
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/generators/fib_generator.rn
0
1
1
2
3
5
8
13
21
34
55
89
144
== () (14.9441ms)
</code></pre>
<h2><a class="header" href="#advanced-generators-with-generatorstate" id="advanced-generators-with-generatorstate">Advanced generators with <code>GeneratorState</code></a></h2>
<p>Generators internally are a bit more complex than that.
The <code>next</code> function simply slates over some of that complexity to make simple
things easier to do.</p>
<p>The first thing to know is that <code>yield</code> itself can actually <em>produce</em> a value,
allowing the calling procedure to send values to the generator.</p>
<pre><code class="language-rune">fn printer() {
    loop {
        let out = yield;
        dbg(out);
    }
}

fn main() {
    let printer = printer();
    printer.resume(1);
    printer.resume(&quot;John&quot;);
    printer.resume((1, 2, 3));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/generators/send_values.rn
&quot;John&quot;
(1, 2, 3)
== () (883.2¬µs)
</code></pre>
<p>But wait, what happened to the first value we sent, <code>1</code>?</p>
<p>Well, generators don't run immediately, they need to be &quot;warmed up&quot; by calling
resume once.
At that point it runs the block prior to the first yield, we can see this by
instrumenting our code a little.</p>
<pre><code class="language-rune">fn printer() {
    loop {
        println(&quot;waiting for value...&quot;);
        let out = yield;
        dbg(out);
    }
}

fn main() {
    let printer = printer();

    println(&quot;firing off the printer...&quot;);
    printer.resume(());
    println(&quot;ready to go!&quot;);

    printer.resume(&quot;John&quot;);
    printer.resume((1, 2, 3));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/generators/bootup.rn
firing off the printer...
waiting for value...
ready to go!
&quot;John&quot;
waiting for value...
(1, 2, 3)
waiting for value...
== () (8.8014ms)
</code></pre>
<p>Ok, so we understand how to <em>send</em> values into a generator.
But how do we <em>receive</em> them?</p>
<p>This adds a bit of complexity, since we need to pull out <code>GeneratorState</code>.
This enum has two variants: <code>Yielded</code> and <code>Complete</code>, and represents all the
possible states a generator can suspend itself into.</p>
<pre><code class="language-rune">fn print_once() {
    let out = yield 1;
    dbg(out);
    2
}

fn main() {
    let printer = print_once();
    dbg(printer.resume(()));
    dbg(printer.resume(&quot;John&quot;));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/generators/states.rn
Yielded(1)
&quot;John&quot;
Complete(2)
== () (712.7¬µs)
</code></pre>
<p>After the first call to resume, we see that the generator produced <code>Yielded(1)</code>.
This corresponds to the <code>yield 1</code> statement in the generator.</p>
<p>The second value we get is <code>Complete(2)</code>.
This corresponds to the <em>return value</em> of the generator.</p>
<p>Trying to resume the generator after this will cause the virtual machine to
error.</p>
<pre><code class="language-rune">fn print_once() {
    yield 1
}

fn main() {
    let printer = print_once();
    dbg(printer);
    dbg(printer.resume(()));
    dbg(printer.resume(&quot;John&quot;));
    dbg(printer);
    dbg(printer.resume(()));
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/generators/error.rn
Generator { completed: false }
Yielded(1)
Complete(&quot;John&quot;)
Generator { completed: true }
error: virtual machine error
   ‚îå‚îÄ scripts/book/generators/error.rn:11:9
   ‚îÇ
11 ‚îÇ     dbg(printer.resume(()));
   ‚îÇ         ^^^^^^^^^^^^^^^^^^ cannot resume a generator that has completed
</code></pre>
<h1><a class="header" href="#closures" id="closures">Closures</a></h1>
<p>We've gone over functions before, and while incredibly useful there's a few more
tricks worth mentioning.</p>
<p>We'll also be talking about closures, an anonymous function with the ability to
<em>close over</em> its environment, allowing the function to use and manipulate things
from its environment.</p>
<h2><a class="header" href="#function-pointers" id="function-pointers">Function pointers</a></h2>
<p>Every function can be converted into a function pointer simply by referencing
its name without calling it.</p>
<p>This allows for some really neat tricks, like passing in a function which
represents the operation you want another function to use.</p>
<pre><code class="language-rune">fn do_thing(op) {
    op(1, 2)
}

fn add(a, b) {
    a + b
}

fn sub(a, b) {
    a - b
}

fn main() {
    println(`{do_thing(add)}`);
    println(`{do_thing(sub)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/closures/function_pointers.rn
Result: 3
Result: -1
== () (5.4354ms)
</code></pre>
<h2><a class="header" href="#closures-1" id="closures-1">Closures</a></h2>
<p>Closures are anonymous functions which closes over their environment.
This means that they capture any variables used inside of the closure, allowing
them to be used when the function is being called.</p>
<pre><code class="language-rune">fn work(op) {
    op(1, 2)
}

fn main() {
    let n = 1;
    println(`Result: {work(|a, b| n + a + b)}`);
    println(`Result: {work(|a, b| n + a * b)}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/closures/basic_closure.rn
Result: 4
Result: 3
== () (5.4354ms)
</code></pre>
<blockquote>
<p>Hint: Closures which do not capture their environment are <em>identical</em> in
representation to a function.</p>
</blockquote>
<h1><a class="header" href="#functions-outside-of-the-vm" id="functions-outside-of-the-vm">Functions outside of the Vm</a></h1>
<p>Now things get <em>really</em> interesting.
Runestick, the virtual machine driving Rune, has support for passing function
pointers out of the virtual machine using the <code>Function</code> type.</p>
<p>This allows you to write code that takes a function constructed in Rune, and use
it for something else.</p>
<p>Below we showcase this, with the help of the <code>rune!</code> macro from <code>rune-testing</code>.</p>
<pre><code class="language-rust noplaypen">use rune_testing::*;

fn main() -&gt; runestick::Result&lt;()&gt; {
    let function: Function = rune! {
        Function =&gt; r#&quot;
        fn foo(a, b) {
            a + b
        }

        fn main() {
            foo
        }
        &quot;#
    };

    println!(&quot;{}&quot;, function.call::&lt;(i64, i64), i64&gt;((1, 3))?);
    println!(&quot;{}&quot;, function.call::&lt;(i64, i64), i64&gt;((2, 6))?);
    Ok(())
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run --example call_rune_fn
4
8
</code></pre>
<p>Note that these functions by necessity have to capture their entire context and
can take up quite a bit of space if you keep them around while cycling many
contexts or units.</p>
<h1><a class="header" href="#asynchronous-programming" id="asynchronous-programming">Asynchronous programming</a></h1>
<p>Rune has first class support for Rust-like asynchronous programming.
In this section we'll be briefly covering what asynchronous programming is, and
how it applies to Rune as a dynamic programming language.</p>
<h2><a class="header" href="#what-is-it" id="what-is-it">What is it?</a></h2>
<p>Asynchronous code allows us to run multiple tasks concurrently, and work with
the result of those tasks.</p>
<p>A typical example would be if we want to perform multiple HTTP requests at once:</p>
<pre><code class="language-rune">async fn main() {
    let a = http::get(&quot;https://google.com&quot;);
    let b = http::get(&quot;https://amazon.com&quot;);

    loop {
        let res = select {
            res = a =&gt; res?,
            res = b =&gt; res?,
        };

        match res {
            () =&gt; break,
            result =&gt; {
                println(`{result.status()}`);
            }
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/async/async_http.rn
200 OK
200 OK
== () (591.0319ms)
</code></pre>
<p>In the above code we send two requests <em>concurrently</em>. They are both processed
at the same time and we collect the result.</p>
<h2><a class="header" href="#select-blocks" id="select-blocks"><code>select</code> blocks</a></h2>
<p>A fundamental construct of async programming in Rune is the <code>select</code> block.
It enables us to wait on a set of futures at the same time.</p>
<p>A simple example of this is if we were to implement a simple request with a
timeout:</p>
<pre><code class="language-rune">struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    println(`{result.status()}`);
    Ok(())
}

async fn main() {
    if let Err(Timeout) = request(1000).await {
        println(&quot;Request timed out!&quot;);
    }

    if let Err(Timeout) = request(4000).await {
        println(&quot;Request timed out!&quot;);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/async/async_http_timeout.rn
200 OK
Request timed out!
== () (3.2231404s)
</code></pre>
<p>But wait, this is taking three seconds. We're not running the requests
concurrently any longer!</p>
<p>Well, while the request and the <em>timeout</em> is run concurrently, the <code>request</code>
function is run one at-a-time.</p>
<p>To fix this we need two new things: <code>async</code> functions and <code>.await</code>.</p>
<h2><a class="header" href="#async-functions" id="async-functions"><code>async</code> functions</a></h2>
<p><code>async</code> functions are just like regular functions, except that when called they
produce a <code>Future</code>.</p>
<p>In order to get the result of this <code>Future</code> it must be <code>.await</code>ed. And <code>.await</code>
is only permitted inside of <code>async</code> functions and closures.</p>
<pre><code class="language-rune">use std::future;

struct Timeout;

async fn request(timeout) {
    let request = http::get(`http://httpstat.us/200?sleep={timeout}`);
    let timeout = time::delay_for(time::Duration::from_secs(2));

    let result = select {
        _ = timeout =&gt; Err(Timeout),
        res = request =&gt; res,
    }?;

    Ok(result)
}

async fn main() {
    for result in future::join([request(1000), request(4000)]).await {
        match result {
            Ok(result) =&gt; println(`Result: {result.status()}`),
            Err(Timeout) =&gt; println(&quot;Request timed out!&quot;),
        }
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/async/async_http_concurrent.rn
Result: 200 OK
Request timed out!
== () (2.0028603s)
</code></pre>
<h2><a class="header" href="#async-closures" id="async-closures"><code>async</code> closures</a></h2>
<p>Closures can be prefixed with the <code>async</code> keyword, meaning calling them will
produce a future.</p>
<pre><code class="language-rune">fn do_request(url) {
    async || {
        Ok(http::get(url).await?.status())
    }
}

async fn main() {
    let future = do_request(&quot;https://google.com&quot;);
    let status = future().await?;
    println(`Status: {status}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/async/async_closure.rn
Status: 200 OK
== () (165.4817ms)
</code></pre>
<h2><a class="header" href="#async-blocks" id="async-blocks"><code>async</code> blocks</a></h2>
<p>Blocks can be marked with <code>async</code> to produce on-the-fly futures. These blocks
can capture variables the same way as closures do, but take no arguments.</p>
<pre><code class="language-rune">fn do_request(url) {
    async {
        Ok(http::get(url).await?.status())
    }
}

async fn main() {
    let future = do_request(&quot;https://google.com&quot;);
    let status = future.await?;
    println(`Status: {status}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/async/async_blocks.rn
Status: 200 OK
== () (179.9381ms)
</code></pre>
<h1><a class="header" href="#streams" id="streams">Streams</a></h1>
<p>Streams are the asynchronous version of <a href="./7_generators.html">Generators</a>.</p>
<p>They have almost identical <code>next</code> and <code>resume</code> functions, but each must be used
with <code>.await</code>, and we are now allowed to use asynchronous functions inside of
the generator.</p>
<pre><code class="language-rune">async fn send_requests(list) {
    let client = http::Client::new();

    let do_request = async |url| {
        let response = client.get(url).await?;
        Ok(response.send().await?.status())
    };

    for url in list {
        yield do_request(url).await;
    }
}

async fn main() {
    let requests = send_requests([
        &quot;https://google.com&quot;,
        &quot;https://amazon.com&quot;,
    ]);

    while let Some(status) = requests.next().await.transpose()? {
        println(`{status}`);
    }
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/streams/basic_stream.rn
200 OK
200 OK
== () (754.3946ms)
</code></pre>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>Rune has (experimental) support for macros. These are functions which expand
into code, and can be used by library writers to &quot;extend the compiler&quot;.</p>
<p>For now, the following type of macros are support:</p>
<ul>
<li>Function-like macros expanding to items (functions, type declarations, ..).</li>
<li>Function-like macros expanding to expression (statements, blocks, async blocks, ..).</li>
</ul>
<p>Macros can currently only be defined natively. This is to get around the rather
tricky issue that the code of a macro has to be runnable during compilation.
Native modules have an edge here, because they have to be defined at a time when
they are definitely available to the compiler.</p>
<blockquote>
<p>Don't worry though, we will be playing around with <code>macro fn</code> as well, but at
a later stage üòâ (See <a href="https://github.com/rune-rs/rune/issues/27">issue #27</a>).</p>
</blockquote>
<p>Native modules also means we can re-use all the existing compiler infrastructure
for Rune as a library for macro authors. Which is really nice!</p>
<h2><a class="header" href="#writing-a-native-macro" id="writing-a-native-macro">Writing a native macro</a></h2>
<p>The following is the definition of the <code>stringy_math!</code> macro. Which is a macro
that can be invoked on expressions.</p>
<p>This relies heavily on a Rune-specific <a href="https://docs.rs/rune/0/rune/macro.quote.html"><code>quote!</code> macro</a>. Which is inspired by its
<a href="https://docs.rs/quote/1/quote/">famed counterpart in the Rust world</a>. A major difference with Rune <code>quote!</code> is
that we need to pass in the <code>MacroContext</code> when invoking it. This is a detail
which will be covered in one of the advanced sections.</p>
<pre><code class="language-rust noplaypen">use rune::ast;
use rune::Resolve as _;
use rune::{quote, MacroContext, Parser, TokenStream};

/// Implementation for the `stringy_math!` macro.
pub(crate) fn stringy_math(
    ctx: &amp;mut MacroContext,
    stream: &amp;TokenStream,
) -&gt; runestick::Result&lt;TokenStream&gt; {
    let mut parser = Parser::from_token_stream(stream);

    let mut output = quote!(ctx =&gt; 0);

    while !parser.is_eof()? {
        let op = parser.parse::&lt;ast::Ident&gt;()?.macro_resolve(ctx)?;

        match op.as_ref() {
            &quot;add&quot; =&gt; {
                let op = parser.parse::&lt;ast::Expr&gt;()?;
                output = quote!(ctx =&gt; (#output) + #op);
            }
            &quot;sub&quot; =&gt; {
                let op = parser.parse::&lt;ast::Expr&gt;()?;
                output = quote!(ctx =&gt; (#output) - #op);
            }
            &quot;div&quot; =&gt; {
                let op = parser.parse::&lt;ast::Expr&gt;()?;
                output = quote!(ctx =&gt; (#output) / #op);
            }
            &quot;mul&quot; =&gt; {
                let op = parser.parse::&lt;ast::Expr&gt;()?;
                output = quote!(ctx =&gt; (#output) * #op);
            }
            other =&gt; {
                return Err(runestick::Error::msg(format!(
                    &quot;unsupported operation `{}`&quot;,
                    other
                )));
            }
        }
    }

    parser.parse_eof()?;
    Ok(output)
}
</code></pre>
<p>A macro is added to a <a href="https://docs.rs/runestick/0/runestick/module/struct.Module.html"><code>Module</code></a> using the <a href="https://docs.rs/runestick/0/runestick/module/struct.Module.html#method.macro_"><code>Module::macro_</code></a> function.</p>
<pre><code class="language-rust noplaypen">pub fn module() -&gt; Result&lt;runestick::Module, runestick::ContextError&gt; {
    let mut module = runestick::Module::new(&amp;[&quot;std&quot;, &quot;experiments&quot;]);
    module.macro_(&amp;[&quot;stringy_math&quot;], stringy_math_macro::stringy_math)?;
    Ok(module)
}
</code></pre>
<p>With this module installed, we can now take <code>stringy_math!</code> for a spin.</p>
<pre><code class="language-rune">use std::experiments::stringy_math;

fn main() {
    let output = stringy_math!(add 10 sub 2 div 3 mul 100);
    println(`{output}`);
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/macros/stringy_math.rn -O macros=true --experimental
200
== () (2.9737ms)
</code></pre>
<p>Until macros are considered somewhat stable, they will be hidden behind the <code>-O macros=true</code> compiler option. This can be set programmatically in
<a href="https://docs.rs/rune/0/rune/struct.Options.html#method.macros"><code>Options::macros</code></a>. <code>--experimental</code> is an option to Rune CLI which adds the
<code>std::experimental</code> module, which contains weird and experimental things like
<code>stringy_math!</code>.</p>
<h1><a class="header" href="#advanced" id="advanced">Advanced</a></h1>
<p>This chapter is dedicated to the advanced topics of Rune. Here we will discuss
the advanced and internal details of the language. This chapter is primarily
targeted at people who want to understand Rune and Runestick in detail.</p>
<h1><a class="header" href="#safety" id="safety">Safety</a></h1>
<p>Rune is implemented in Rust, but that doesn't automatically make the language
safe (as Rust defines safety) since there are some uses of <code>unsafe</code>. In this
section we'll be documenting the pieces of the implementation which are
currently <code>unsafe</code>, rationalize, and document potential soundness holes.</p>
<h2><a class="header" href="#conflicts-in-type-hashes" id="conflicts-in-type-hashes">Conflicts in type hashes</a></h2>
<p>GitHub issue: <a href="https://github.com/rune-rs/rune/issues/15">https://github.com/rune-rs/rune/issues/15</a></p>
<p>A type hash is a 64-bit hash which uniquely identifies a type in Rune. The type
hash for an external <code>Any</code> type is currently defined like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn from_type_id(type_id: std::any::TypeId) -&gt; Hash {
    unsafe { std::mem::transmute(type_id) }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>transmute</code> is sound (ish), both are currently defined as 64-bit unsigned
integers. They both just have to be integers, signed or not of the same type.</p>
<p>The issue is that the type check to determine if an <code>Any</code> type is a specific
type is defined like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn is&lt;T&gt;(&amp;self) -&gt; bool
where
    T: std::any::Any,
{
    Hash::from_type_id(std::any::TypeId::of::&lt;T&gt;()) == self.type_hash()
}
<span class="boring">}
</span></code></pre></pre>
<p>We could use <code>TypeId</code> directly here, but <code>TypeId</code>'s cannot be constructed for
types unknown to Rust, which prevent it from being used through a C ffi. A raw
<a href="https://github.com/rune-rs/rune/blob/e910fb9/crates/runestick/src/any.rs#L171"><code>AnyVtable</code></a> has to be usable outside of Rust.</p>
<blockquote>
<p>An interesting detail is that this is actually <a href="https://github.com/rust-lang/rust/issues/10389">a soundness hole in Rust</a>
right now.</p>
</blockquote>
<p>In the future we might also implement a lookaside table stored in the <code>Unit</code> for
types registered in <code>Any</code>, which requires all types used to be registered
beforehand in order to detect these hash conflicts. Any dynamic types already
use such a table at the time we install modules into the <a href="https://docs.rs/runestick/0.6.16/runestick/struct.Context.html"><code>Context</code></a>.</p>
<p>So the current conclusion is:</p>
<ul>
<li>Externally defined types (C ffi) must use properly <em>random</em> type hashes.</li>
<li>The risk for the current safety issue is deemed to be low.</li>
</ul>
<h2><a class="header" href="#internal-any-type" id="internal-any-type">Internal <code>Any</code> type</a></h2>
<p>Rune uses an <a href="https://docs.rs/runestick/0/runestick/struct.Any.html">internal <code>Any</code> type</a>.</p>
<p>Apart from the <a href="safety.html#conflicts-in-type-hashes">hash conflict</a> documented above, the
implementation should be sound. We have an internal <code>Any</code> type instead of
relying on <code>Box&lt;dyn Any&gt;</code> to allow <a href="https://github.com/rune-rs/rune/blob/e910fb9/crates/runestick/src/any.rs#L171"><code>AnyVtable</code></a> to be implementable by external
types to support external types through a C ffi.</p>
<h2><a class="header" href="#sharedt-and-unsafefromvalue" id="sharedt-and-unsafefromvalue"><code>Shared&lt;T&gt;</code> and <code>UnsafeFromValue</code></a></h2>
<p>A large chunk of the <code>Shared&lt;T&gt;</code> container is <code>unsafe</code>. This is a container
which is behaviorally equivalent to <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>.</p>
<p>We have this because it merges <code>Rc</code> and <code>RefCell</code> and provides the ability to
have <a href="https://docs.rs/runestick/0/runestick/struct.Shared.html#method.owned_ref">&quot;owned borrows&quot;</a> and the ability to unsafely decompose these into a raw
pointer and a raw guard, which is used in many implementations of
<a href="https://docs.rs/runestick/0/runestick/trait.UnsafeFromValue.html"><code>UnsafeFromValue</code></a>.</p>
<p><a href="https://docs.rs/runestick/0/runestick/trait.UnsafeFromValue.html"><code>UnsafeFromValue</code></a> is a conversion trait which is strictly used internally to
convert values into references. Its safety is documented in the trait.</p>
<h1><a class="header" href="#the-stack" id="the-stack">The stack</a></h1>
<p>Runestick is a stack-based virtual machine. It has two primary places where
things are stored. <em>The stack</em> and <em>the heap</em>. It has no registers.</p>
<p>Instructions in the virtual machine operate off the stack. Let's take a look at
the add operation with <code>--trace</code> and <code>--dump-stack</code>.</p>
<pre><code class="language-rune">fn main() {
    1 + 3
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/the_stack/add.rn --trace --dump-stack
fn main() (0xe7fc1d6083100dcd):
  0000 = integer 1
    0+0 = 1
  0001 = integer 3
    0+0 = 1
    0+1 = 3
  0002 = add
    0+0 = 4
  0003 = return
    *empty*
== 4 (7.7691ms)
# stack dump after halting
frame #0 (+0)
    *empty*
</code></pre>
<p>Let's examine the stack after each instruction.</p>
<pre><code class="language-text">  0000 = integer 1
    0+0 = 1
</code></pre>
<p>We evaluate the <code>integer 1</code> instruction, which pushes an integer with the value
<code>1</code> onto the stack.</p>
<pre><code class="language-text">  0001 = integer 3
    0+0 = 1
    0+1 = 3
</code></pre>
<p>We evaluate the <code>integer 3</code> instruction, which pushes an integer with the value
<code>3</code> onto the stack.</p>
<pre><code class="language-text">  0002 = add
    0+0 = 4
</code></pre>
<p>We evaluate the <code>add</code> instruction which pops two values from the stack and adds
them together. Two integers in this instance would use built-in accelerated
implementations which performs addition.</p>
<pre><code class="language-text">  0003 = return
== 4 (7.7691ms)
</code></pre>
<p>We <code>return</code> from the virtual machine. The last value of the stack will be popped
as the return value.</p>
<pre><code class="language-text"># stack dump
frame #0 (+0)
</code></pre>
<p>This is the stack dump we see after the virtual machine has exited.
It tells us that at call frame <code>#0 (+0)</code>, the last and empty call frame at stack
position <code>+0</code> there is nothing on the stack.</p>
<h1><a class="header" href="#call-frames" id="call-frames">Call frames</a></h1>
<p>Call frames are a cheap isolation mechanism available in the virtual machine.
They define a subslice in the stack, preventing the vm from accessing values
that are outside of the slice.</p>
<p>They have the following rules:</p>
<ul>
<li>Instructions cannot access values outside of their current call frame.</li>
<li>When we return from the call frame the subslice must be empty.</li>
</ul>
<p>If any these two conditions aren't maintained, the virtual machine will error.</p>
<p>Call frames fill two purposes. The subslice provides a well-defined variable
region. Stack-relative operations like <code>copy 0</code> are always defined relative to
the top of their call frame. Where <code>copy 0</code> would mean &quot;copy from offset 0 of
the current stack frame&quot;.</p>
<p>They also provide a cheap security mechanism against <em>miscompilations</em>. This
might be made optional in the future once Rune is more stable, but for now it's
helpful to detect errors early and protect the user against bad instructions.
But don't mistake it for perfect security. Like <a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection">stack protection</a> which is
common in modern operating systems, the mechanism can be circumvented by
malicious code. </p>
<p>To look close at the mechanism, let's trace the following program:</p>
<pre><code class="language-rune">fn foo(a, b) {
    a + b
}

fn main() {
    let a = 3;
    foo(1, 2) + a
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/the_stack/call_and_add.rn --trace --dump-stack
fn main() (0xe7fc1d6083100dcd):
  0005 = integer 3
    0+0 = 3
  0006 = integer 1
    0+0 = 3
    0+1 = 1
  0007 = integer 2
    0+0 = 3
    0+1 = 1
    0+2 = 2
  0008 = call 0xbfd58656ec9a8ebe, 2 // fn `foo`
=&gt; frame 1 (1):
    1+0 = 1
    1+1 = 2
fn foo(arg, arg) (0xbfd58656ec9a8ebe):
  0000 = copy 0 // var `a`
    1+0 = 1
    1+1 = 2
    1+2 = 1
  0001 = copy 1 // var `b`
    1+0 = 1
    1+1 = 2
    1+2 = 1
    1+3 = 2
  0002 = add
    1+0 = 1
    1+1 = 2
    1+2 = 3
  0003 = clean 2
    1+0 = 3
  0004 = return
&lt;= frame 0 (0):
    0+0 = 3
    0+1 = 3
  0009 = copy 0 // var `a`
    0+0 = 3
    0+1 = 3
    0+2 = 3
  0010 = add
    0+0 = 3
    0+1 = 6
  0011 = clean 1
    0+0 = 6
  0012 = return
    *empty*
== 6 (45.8613ms)
# full stack dump after halting
  frame #0 (+0)
    *empty*
</code></pre>
<p>We're not going to go through each instruction step-by-step like in the last
section. Instead we will only examine the parts related to call frames.</p>
<p>We have a <code>call 0xbfd58656ec9a8ebe, 2</code> instruction, which tells the virtual
machine to jump to the function corresponding to the type hash
<code>0xbfd58656ec9a8ebe</code>, and isolate the top two values on the stack in the next
call frame.</p>
<p>We can see that the first argument <code>a</code> is in the <em>lowest</em> position, and the
second argument <code>b</code> is on the <em>highest</em> position. Let's examine the effects this
function call has on the stack.</p>
<pre><code class="language-text">    0+0 = 3
    0+1 = 1
    0+2 = 2
  0008 = call 0xbfd58656ec9a8ebe, 2 // fn `foo`
=&gt; frame 1 (1):
    1+0 = 1
    1+1 = 2
</code></pre>
<p>Here we can see a new call frame <code>frame 1</code> being allocated, and that it contains
two items: <code>1</code> and <code>2</code>.</p>
<p>We can also see that the items are offset from position <code>1</code>, which is the base
of the current call frame. This is shown as the addresses <code>1+0</code> and <code>1+1</code>. The
value <code>3</code> at <code>0+0</code> is no longer visible, because it is outside of the current
call frame.</p>
<p>Let's have a look at what happens when we <code>return</code>:</p>
<pre><code>    1+0 = 1
    1+1 = 2
    1+2 = 3
  0003 = clean 2
    1+0 = 3
  0004 = return
&lt;= frame 0 (0):
    0+0 = 3
    0+1 = 3
</code></pre>
<p>We call the <code>clean 2</code> instruction, which tells the vm to preserve the top of the
stack (<code>1+2</code>), and clean two items below it, leaving us with <code>3</code>. We then
<code>return</code>, which jumps us back to <code>frame 0</code>, which now has <code>0+0</code> visible <em>and</em>
our return value at <code>0+1</code>.</p>
<h1><a class="header" href="#compiler-guide" id="compiler-guide">Compiler guide</a></h1>
<p>This is intended to be a guide into the compiler architecture for Rune for
people who want to hack on it.</p>
<blockquote>
<p><strong>Rune is heavily in development</strong> and this is bound to change in the future.</p>
</blockquote>
<p>Compiling a rune program involves the following stages:</p>
<ul>
<li>Parse and queue the initial source files into <a href="https://github.com/rune-rs/rune/tree/master/crates/rune/src/ast"><code>AST</code></a>, specified by
<a href="https://docs.rs/runestick/0/runestick/struct.Source.html#method.insert_default"><code>Source::insert_default</code></a>.</li>
<li><strong>Indexing and macro expansion</strong>, which processes tasks in the <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/worker.rs"><code>Worker</code></a>
queue until it is empty. These are:
<ul>
<li><code>Task::Index</code> - Index language items.</li>
<li><code>Task::Import</code> - Process imports, expands <code>use</code> items and indexes all
imported names.</li>
<li><code>Task::ExpandMacro</code> - Expand macros (which can add more tasks to the worker
queue).</li>
</ul>
</li>
<li><strong>Compilation</strong> which processes a queue of items to be compiled.</li>
</ul>
<h2><a class="header" href="#indexing" id="indexing">Indexing</a></h2>
<p>Indexing is primarily handled through the <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/index.rs"><code>Index&lt;T&gt;</code></a> trait, which are
implemented for the type being indexed on top of the <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/index.rs"><code>Indexer</code></a>.</p>
<p>This walks through the <a href="https://github.com/rune-rs/rune/tree/master/crates/rune/src/ast"><code>AST</code></a> to be indexed and construct <a href="https://github.com/rune-rs/rune/blob/master/crates/runestick/src/item.rs#L138">components</a> into an
item path for every:</p>
<ul>
<li>Functions, which adds components named after the function. <code>fn foo</code> would add
<code>foo</code>.</li>
<li>Closures, which adds <code>$closure&lt;number&gt;</code> components.</li>
<li>Block, which adds <code>$block&lt;number&gt;</code> components.</li>
<li>Async blocks, which adds <code>$async&lt;number&gt;</code> components.</li>
<li>Macro calls, which adds <code>$macro&lt;number&gt;</code> components, and queues a
<code>Task::ExpandMacro</code> task.</li>
</ul>
<h2><a class="header" href="#compilation" id="compilation">Compilation</a></h2>
<p>The compilation stage processed the entire <a href="https://github.com/rune-rs/rune/tree/master/crates/rune/src/ast"><code>AST</code></a> of every function that is
queued to be compiled and generates a sequence of instructions for them through
implementations of the <a href="https://github.com/rune-rs/rune/tree/master/crates/rune/src/compile"><code>Compile&lt;T&gt;</code></a> trait.</p>
<p>This stage uses the <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/query.rs"><code>Query</code></a> system to look up metadata about external items,
and any external item queried for is subsequently queued up to be built.</p>
<p>Consider the following unit:</p>
<pre><code class="language-rune">fn main() {
    return foo();

    fn foo() {
        2
    }

    fn bar() {
        3
    }
}
</code></pre>
<p>Let's dump all dynamic functions in it:</p>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/compiler_guide/dead_code.rn --dump-functions
# dynamic functions
0xe7fc1d6083100dcd = main()
0x20c6d8dd92b51018 = main::$block0::foo()
---
== 2 (59.8¬µs)
</code></pre>
<p>As you can see, the code for <code>main::$block0::bar</code> was <em>never generated</em>. This is
because it's a local function that is never called. And therefore never queried
for. So it's never queued to be built in the compilation stage.</p>
<h2><a class="header" href="#state-during-compilation" id="state-during-compilation">State during compilation</a></h2>
<p>Each item in the AST is relatively isolated while they are being compiled. This
is one of the benefits of compiling for a stack-based virtual machine - the
compilation stage is relatively simple and <em>most</em> reasoning about what
instructions to emit can be made locally.</p>
<blockquote>
<p>Note that this quickly changes if you want to perform most forms of
optimizations. But it's definitely true for naive (and therefore fast!) code
generation.</p>
</blockquote>
<p>While compiling we keep track of the following state in the <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/compiler.rs"><code>Compiler</code></a></p>
<p>The source file and id that we are compiling for and global storage used for
macro-generated identifiers and literals. This is used to resolve values from
the AST through the corresponding <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/traits.rs"><code>Resolve</code></a> implementation. An example of this
is the <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/ast/lit_str.rs"><code>Resolve</code> implementation of <code>LitStr</code></a>.</p>
<p>We keep track of local variables using <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/scopes.rs"><code>Scopes</code></a>. Each block creates a new
scope of local variables, and this is simply a number that is incremented each
time a variable is allocated. These can either be named or anonymous. Each named
variable is associated with an offset relative to the current <a href="./call_frames.html">call
frame</a> that can be looked up when a variable needs to be used.</p>
<p>We maintain information on loops we're through <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/loops.rs"><code>Loops</code></a>. This is a stack that
contains every loop we are nested in, information on the label in which the loop
terminates, and locals that would have to be cleaned up in case we encounter a
<a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/compile/expr_break.rs"><code>break</code> expression</a>.</p>
<p>We maintain the current <a href="./items_imports.html">item path</a> which is being traversed
through <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/items.rs"><code>Items</code></a>. This is populated in the same way as during indexing. We use
this to query for compile meta or other things which were indexed, like the AST
produced by expanded macros. Another example is if we encounter a <a href="https://github.com/rune-rs/rune/blob/master/crates/rune/src/compile/expr_closure.rs"><code>closure</code>
expression</a> in this phase we generate an instruction to create a closure rather
than constructing its body. This is actually accomplished through two separate
<code>Compile&lt;T&gt;</code> implementations.</p>
<ul>
<li><code>Compile&lt;(ast::ExprClosure, &amp;[CompileMetaCapture])&gt;</code> - which is used when
compiling the closure function from the compile queue.</li>
<li><code>Compile&lt;(&amp;ast::ExprClosure, Needs)&gt;</code> - which is for compiling the closure
invocation.</li>
</ul>
<p>The closure procedure would be compiled and inserted into the unit separately at
a given item (like <code>foo::$block0::closure1</code>). And when we invoke the closure, we
<em>call</em> this item.</p>
<p>We can see this call by dumping all the dynamic functions in the following
script:</p>
<pre><code class="language-rune">fn main() {
    let callable = || 42;
    callable();
}
</code></pre>
<pre><code class="language-text">$&gt; cargo run -- scripts/book/compiler_guide/closures.rn --dump-instructions --dump-functions
# instructions
fn main() (0xe7fc1d6083100dcd):
  0000 = fn 0x9aa62663879132fb // closure `main::$block0::$closure0`
  0001 = copy 0 // var `callable`
  0002 = call-fn 0
  0003 = pop
  0004 = pop
  0005 = return-unit

fn main::$block0::$closure0() (0x9aa62663879132fb):
  0006 = integer 42
  0007 = return
# dynamic functions
0x9aa62663879132fb = main::$block0::$closure0()
0xe7fc1d6083100dcd = main()
== () (108.6¬µs)
</code></pre>
<p>A function pointer is pushed on the stack <code>fn 0x9aa62663879132fb</code>, then copied
and called with zero arguments.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
